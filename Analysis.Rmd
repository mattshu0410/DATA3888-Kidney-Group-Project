---
title: "Main Analysis"
author: Matthew Shu; Raymond Huang; Hugo Ohlsson; Vasu Paliwal; Ruestam Bhangal; Jiani
  Tan
date: "03/04/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, results='hide', warning=FALSE, message=FALSE}
library(dplyr)
library(tidyr)
library(devtools)
library(ggplot2)
library(stringr)
library(stringdist)
library(BiocManager)
library(GEOquery) 
library(R.utils)
library(Biobase)
library(reshape2)
library(ggplot2)
library(limma)
library(stats)
library(blorr)
library(viridis)
library(plotly)
library(ggrepel)
library(CPOP)
library(clusterProfiler)
library(DOSE)
library(org.Hs.eg.db)
library(pathview)
library(stringr)
library(gtools)
library(rpart)
library(yardstick)
library(enrichplot)
library(msigdbr)
#BiocManager::install("sva")

```

## Inspiration / Overall Focus

https://imageo.genyo.es/

The following is an excerpt from GSE36059 report. It outlines the clinical recommendations that could be made off the back of being able to differentiate TCMR from ABMR. It is important to note that these biopsies are taken post-transplant.

"
The significance of the AKI score is dictated by the inducing
insult, which can be:
(1) self-limited, for example, early AKI in kidney transplants;
(2) treatable, for example, TCMR;
(3) difficult to treat and sustained, for example, late ABMR
or recurrent glomerulonephritis.
The conclusion that progression in troubled transplants is
primarily a function of ongoing parenchymal injury, not
destructive fibrosis, has promising therapeutic implications:
if we can arrest the disease that is wounding nephrons (e.g.
ABMR) before the renal tissue is too badly damaged, the
kidney will stabilize. The corollary is that treatments directed
at arresting fibrosis may not be useful because they fail to
address the cause of parenchymal injury.
...

TCMR after treatment in experienced centers is not
associated with reduced graft survival if there is no ABMR,
although TCMR should always trigger a review of the
immunosuppressive drug (ISD) prescription and patient
adherence. 


"

How to treat ABMR 
https://pubmed.ncbi.nlm.nih.gov/31895348/

## Datasets Ingestion & Cleaning

### GSE36059

https://www.sciencedirect.com/science/article/pii/S0085253815561863#bb0095



Human leukocyte antigen (HLA) antibodies were initially recognised as responsible for the immediate, hyperacute rejection of kidney grafts. Later we began to distinguish between two more types of rejection.

*  TCMR (T-cell Mediated Rejection) 
*  ABMR (Antibody Mediated Rejection)

C4d is a complement component i.e. molecule that tends to build up in the peritubular capillaries of kidneys, and was found to be a hallmark of anti-body mediated rejection. ABMR could both affect patients immediately (those who were presensitised) or much later due to de novo DSA production i.e. their body starting producing new antibodies against the donor's tissue. Both would eventually end up in end-stage renal failure.

It seems that this research finds ABMR to be primarily linked to a high probability of end-stage renal failure whereas TCMR probability of renal failure actually decreases over time. Distinguishing these could provide crucial clinical details as timing is a major factor in decision making.

![image](https://ars.els-cdn.com/content/image/1-s2.0-S0085253815561863-gr1.jpg)
Entrez Gene ID are unique alphanumeric identifiers for genes and other loci.

```{r}
# Reading in Data
GEO_GSE36059 = getGEO("GSE36059")
GSE36059 = GEO_GSE36059$GSE36059_series_matrix.txt.gz

# Example of functions that return patient data, feature data, expression matrix
#head(pData(GSE36059)[,1:5])
#head(fData(GSE36059)[,1:5])
#head(exprs(GSE36059)[,1:5])

# How to return gene names
#rownames(eMat_GSE36059)
#length(rownames(eMat_GSE36059))

# Load relevant matrices
eMat_GSE36059 = exprs(GSE36059)
p_GSE36059 = dplyr::rename(pData(GSE36059), diagnosis = `diagnosis:ch1`)
p_GSE36059$diagnosis = gsub("non-rejecting", "NR", p_GSE36059$diagnosis)

# Rows & patient id with control diagnosis of nephrectomy
control_idx = which(p_GSE36059$diagnosis == "Nephrectomy" | p_GSE36059$diagnosis == "MIXED")
remove_patient_id = rownames(p_GSE36059)[control_idx]

# Remove controls from patient and expression dataset
p_GSE36059 = p_GSE36059[!(row.names(p_GSE36059) %in% remove_patient_id),]
eMat_GSE36059 = eMat_GSE36059[, !(colnames(eMat_GSE36059) %in% remove_patient_id)]

# Multiple probes test same genes
#sum(duplicated(fData(GSE36059)$`Gene Symbol`))

# List of the main genes
all_gene_symbols = unlist(lapply(strsplit(fData(GSE36059)$`Gene Symbol`, ' /// ', 1), `[`, 1))

# Get index of probe_ids to keep which are not duplicates or have NA values
#idx = which(!duplicated(fData(GSE36059)$`Gene Symbol`) & !is.na(fData(GSE36059)$`Gene Symbol`))
idx = which(!duplicated(all_gene_symbols) & !is.na(fData(GSE36059)$`Gene Symbol`) & !(fData(GSE36059)$`Gene Symbol` == ""))
# Remove duplicate gene probes & probes w/o gene names
eMat_GSE36059 = eMat_GSE36059[idx,]

# Print gene symbols
gene_symbols = fData(GSE36059) %>%
  dplyr::select(ID, `Gene Symbol`) 
kept_gene_symbols = gene_symbols[idx,] %>% dplyr::pull(`Gene Symbol`)

# Map Affymetrix gene probe to gene symbol
AFFX_gene_symbols = gene_symbols[idx,] %>% mutate(`Gene Symbol` = all_gene_symbols[idx] )

# Replace probe ids with gene names
rownames(eMat_GSE36059) = lapply(strsplit(kept_gene_symbols, ' /// ', 1), `[`, 1)


```

### GSE48581

https://onlinelibrary.wiley.com/doi/10.1111/ajt.12387



https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4788702/

According to the paper above, nephrectomy is usually performed on patients with autosomal-dominant polycystic kidney disease, which is a common hereditary disorder.
The patients with nephrectomy were included as a baseline according to the original paper of this dataset.

```{r}
GEO_GSE48581 = getGEO("GSE48581")
GSE48581 = GEO_GSE48581$GSE48581_series_matrix.txt.gz

# Load relevant matrices
eMat_GSE48581 = exprs(GSE48581)
p_GSE48581 = dplyr::rename(pData(GSE48581), diagnosis = `diagnosis (tcmr, abmr, mixed, non-rejecting, nephrectomy):ch1` )

# Rename non-rejecting level
p_GSE48581$diagnosis = gsub("non-rejecting", "NR", p_GSE48581$diagnosis)


# Remove rows & patient id with control diagnosis of nephrectomy or mixed
control_idx = which(p_GSE48581$diagnosis == "nephrectomy" | p_GSE48581$diagnosis == "mixed")
remove_patient_id = rownames(p_GSE48581)[control_idx]

# Remove from patient and expression dataset
p_GSE48581 = p_GSE48581[!(row.names(p_GSE48581) %in% remove_patient_id),]
eMat_GSE48581 = eMat_GSE48581[, !(colnames(eMat_GSE48581) %in% remove_patient_id)]



# Multiple probes test same genes
#sum(duplicated(fData(GSE48581)$`Gene Symbol`))

# List of the main genes
all_gene_symbols = unlist(lapply(strsplit(fData(GSE48581)$`Gene Symbol`, ' /// ', 1), `[`, 1))

# Get index of probe_ids to keep which are not duplicates or have NA values
#idx = which(!duplicated(fData(GSE48581)$`Gene Symbol`) & !is.na(fData(GSE48581)$`Gene Symbol`))
idx = which(!duplicated(all_gene_symbols) & !is.na(fData(GSE48581)$`Gene Symbol`) & !(fData(GSE48581)$`Gene Symbol` == ""))
# Remove duplicate gene probes & probes w/o gene names
eMat_GSE48581 = eMat_GSE48581[idx,]

# Print gene symbols
gene_symbols = fData(GSE48581) %>%
  dplyr::select(ID, `Gene Symbol`) 
kept_gene_symbols = gene_symbols[idx,] %>% dplyr::pull(`Gene Symbol`)

# Replace probe ids with gene names
rownames(eMat_GSE48581) = lapply(strsplit(kept_gene_symbols, ' /// ', 1), `[`, 1)
```




### Further Cleaning

```{r}
# Check to ensure there aren't shared patients between datasets
intersect(rownames(pData(GSE36059)), rownames(pData(GSE48581)))

# Check if there is any differences in genes measured between two dataset
setdiff(rownames(eMat_GSE48581), rownames(eMat_GSE36059))

```

## Joining & Merging

Joining & merging datasets from different batches i.e. experiments is difficult because it's necessary to remove batch effects which are differences that are not clinically significant (technician, reagents, microarray chips, and other equipment). The following reference outlines many more possible causes.

Problems with merging: https://www.nature.com/articles/tpj201057#

In the past many other batch correction methods have been used e.g. mean centering & standardising variance. The standard way to do it now appears to be to use the ComBat method to batch-adjust the gene expression. It uses an empirical Bayes and is predicated on the notion that batch effects are systematic & affect many genes in a batch in a similar way e.g. (increasing expression or increasing variability.) It shrinks the batch effect parameter estimates towards the global mean of batch effect estimates.

Original Batch Correction: https://academic.oup.com/biostatistics/article/8/1/118/252073
In action: https://biodatamining.biomedcentral.com/articles/10.1186/s13040-020-00217-8


## Relative Gene Expression

https://www.researchgate.net/publication/289524168_Pathway_Analysis_State_of_the_Art

This paper explains what we do which is first select for genes using Over Representation Analysis (ORA). THere is some evidence to suggest there are weaknesses to this method.

https://www.pnas.org/doi/full/10.1073/pnas.0506580102

The following can be used for justifying procedure.

https://academic.oup.com/nar/article/43/7/e47/2414268?ref=https%3a%2f%2fgithubhelp.com&login=false

### Selecting Genes

#### Using limma on pairwise contrasts

```{r}
library(DT)

# Takes lmFit model, contrast matrix, condition (ABMR or TCMR), returns top table dataframe & genes selected
ORA_contrasts = function(fit, contrast_matrix, condition){
  # For linear model fit of microarray data, compute estimated coefficients and standard errors for given contrasts
  constrast_fit = contrasts.fit(fit, contrast = contrast_matrix[, condition])
  # Adjust standard errors towards empirical derived global value
  efit = eBayes(constrast_fit, robust = TRUE)
  # Show how many genes were significant
  #summary(decideTests(efit, adjust.method = "BH", p.value = 0.05))
  tT = topTable(efit, n = 200, p.value = 0.05)
  # Rounding because significant figures
  DT::datatable(round(tT[1:100,], 2))
  return(tT)
}

# Takes pData with diagnosis column at levels ("ABMR", "TCMR", "NR"), expression matrix, returns list of topTables
get_ORA_genes = function(patient_data, expression_matrix) {
  design = model.matrix(~0 + diagnosis, data = patient_data)
  colnames(design) = gsub("diagnosis", "", colnames(design))
  fit = lmFit(expression_matrix, design)
  CM = makeContrasts(ABMR = ABMR - NR,
                     TCMR = TCMR - NR,
                     levels = design)
  tT_ABMR = ORA_contrasts(fit, CM, "ABMR")
  tT_TCMR = ORA_contrasts(fit, CM, "TCMR")
  return(list("tT_ABMR" = tT_ABMR, "tT_TCMR" = tT_TCMR))
}


# Finds only the names of the ABMR vs Healthy genes significant to both datasets
tT_ABMR_48581 = get_ORA_genes(p_GSE48581, eMat_GSE48581)$tT_ABMR
tT_ABMR_36059 = get_ORA_genes(p_GSE36059, eMat_GSE36059)$tT_ABMR
genes_selected_ABMR = intersect(rownames(tT_ABMR_36059), rownames(tT_ABMR_48581))

# Finds only the names of the TCMR vs Healthy genes significant to both datasets
tT_TCMR_48581 = get_ORA_genes(p_GSE48581, eMat_GSE48581)$tT_TCMR
tT_TCMR_36059 = get_ORA_genes(p_GSE36059, eMat_GSE36059)$tT_TCMR
genes_selected_TCMR = intersect(rownames(tT_TCMR_36059), rownames(tT_TCMR_48581))

```

#### Average or Single Dataset Fold Change

We can either plot the following exploratory plots based on the average log fold change between the two datasets or generate single plots for each dataset. The plotting functions take in the same arguments for either choice. The plots which use average log fold change are the network plot and the KEGG pathway plot.

What I have realised is that the treeplot and dotplot don't actually consider logFC so it doesn't matter if there are multiple datasets. The treeplots end up involving the same pathways however it is possible that the differing branching (similarity) could mean that different sets of pathways are activated in symphony in different outcomes.

```{r}


# Input two toptables to be combined & significant genes
# Output single average log fold ratio table with ENTREZID
get_average_FC = function(topTable1, topTable2, genes_selected) {
  
  FC_1 = topTable1 %>% 
    dplyr::select(logFC) %>% 
    filter(rownames(topTable1) %in% genes_selected)
  
  FC_2 = topTable2 %>% 
    dplyr::select(logFC) %>% 
    filter(rownames(topTable2) %in% genes_selected)
  
  FC_avg = (FC_1+FC_2)/2
  
  translated = bitr(rownames(FC_avg),
                  fromType = "SYMBOL",
                  toType = "ENTREZID",
                  OrgDb = "org.Hs.eg.db"
                  )
  FC_ENTREZID = FC_avg %>%
    filter(rownames(FC_avg) %in% translated$SYMBOL)
  
  row.names(FC_ENTREZID) = translated$ENTREZID
  
  FC_ENTREZID = setNames(FC_ENTREZID$logFC, rownames(FC_ENTREZID))
  return(FC_ENTREZID)
}

# Input single toptable & significant genes
# Output single log fold ratio table with ENTREZID
get_single_FC = function(topTable, genes_selected) {
  
  FC = topTable %>% 
    dplyr::select(logFC) %>% 
    filter(rownames(topTable) %in% genes_selected)
  
  translated = bitr(rownames(FC),
                  fromType = "SYMBOL",
                  toType = "ENTREZID",
                  OrgDb = "org.Hs.eg.db"
                  )
  
  FC_ENTREZID = FC %>%
    filter(rownames(FC) %in% translated$SYMBOL)
  
  row.names(FC_ENTREZID) = translated$ENTREZID
  FC_ENTREZID = setNames(FC_ENTREZID$logFC, rownames(FC_ENTREZID))
  return(FC_ENTREZID)
}

# Get average log fold changes of significant genes between datasets
FC_ABMR_ENTREZID = get_average_FC(tT_ABMR_48581, tT_ABMR_36059, genes_selected_ABMR)
FC_TCMR_ENTREZID = get_average_FC(tT_TCMR_48581, tT_TCMR_36059, genes_selected_TCMR)

# Alternatively, get log fold changes of a single dataset
#FC_ABMR_ENTREZID = get_single_FC(tT_ABMR_48581, genes_selected_ABMR)


```

### Visualisations

#### Molecular Signatures Functional Enrichment Network Plot

MSigDB is a database of molecular signatures database.
https://www.gsea-msigdb.org/gsea/msigdb/

The following plot requires the log fold changes of each gene.

```{r}


# Input vector with names as ENTREZID & log-fold change values, return enrich result
get_enrich = function(geneList) {
  
  # Retrieves human molecular signatures database v7.5.1
  # Category, H -> Hallmark Gene Sets, C7 -> Immunologic Signature Gene Sets
  msigdbr_df = msigdbr(species = "human", category = "H")
  
  # Prepare term to gene input
  msigdbr_t2g = msigdbr_df %>% dplyr::distinct(gs_name, entrez_gene) %>% as.data.frame()
  
  # Get over-representation results
  enrich = enricher(gene = names(geneList), TERM2GENE = msigdbr_t2g)
  return(enrich)
  
}

# Input vector with names as ENTREZID & log-fold change values, return network plot
make_network_plot = function(geneList){
  
  enrich = get_enrich(geneList)
  # ENTREZID to gene symbol 
  enrich_readable = setReadable(enrich, 'org.Hs.eg.db', 'ENTREZID')
  enrich_readable@result$Description = enrich_readable@result$Description %>%
    str_replace_all("_", " ") %>%
    str_to_sentence()
  
  # Plot a cnetplot
  p1 = cnetplot(enrich_readable, 
                showCategory = 6,
                categorySize="pvalue", 
                foldChange = geneList, 
                cex_label_gene = 0.3,
                colorEdge = TRUE,
                cex_label_category = 0.5
                )
  return(p1)
  
}


```



#### Dot Plot

Dot plot does not use the log fold change values.

```{r}

# Makes strings returned by msigdb look prettier
label_func = function(string){
  
  return(str_to_sentence(str_replace_all(string, "_", " ")))
  
}

# Input vector with names as ENTREZID & log-fold change values, return dotplot
make_dotplot = function(geneList){
  
  enrich = get_enrich(geneList)
  dotplot(enrich, label_format = label_func)
}



```

#### Tree plot

Tree plot does not use the log fold change values.

Following article could help explain why we see TNF-A -> NFKB response

https://www.frontiersin.org/articles/10.3389/fimmu.2019.00815/full

```{r}

# Input vector with names as ENTREZID & log-fold change values, return tree plot
make_treeplot = function(geneList){
  
  enrich = get_enrich(geneList)
  # ENTREZID to gene symbol 
  enrich_readable = setReadable(enrich, 'org.Hs.eg.db', 'ENTREZID')
  # Calculates pairwsie similarity using Jaccard's similarity index
  similiarity_enrich = pairwise_termsim(enrich_readable)
  # Tree plot where default agglomeration method uses ward.D
  p1 = treeplot(similiarity_enrich)
  return(p1)
  
}

```

#### KEGG Enrichment Analysis

Kyoto Encyclopedia of Genes and Genomes is a database which helps us understand high-level functional pathways.

```{r}
#search_kegg_organism('hsa', by='kegg_code')
get_KEGG_plot = function(geneList){
  # Searches for relevant pathways based on selected genes
  kk = enrichKEGG(gene = names(geneList),
                  organism = 'hsa',
                  pvalueCutoff = 0.05)
  # Shows upregulated pathways, pay attention to ID column
  for (id in head(kk)$ID){
    # Saves an image of the pathway in root as {ID}.pathview.png e.g. hsa05332.pathview.png
    pathview(gene.data  = geneList,
           pathway.id = id,
           species    = "hsa",
           limit      = list(gene=max(abs(geneList)), cpd=1))
  }
}

```

```{r}
# Saves in local folder
get_KEGG_plot(FC_TCMR_ENTREZID)

```

#### Using the Plot Functions

```{r}

library(enrichplot)
make_network_plot(FC_ABMR_ENTREZID)
make_network_plot(FC_TCMR_ENTREZID)
make_dotplot(FC_ABMR_ENTREZID)
make_dotplot(FC_TCMR_ENTREZID)
make_treeplot(FC_ABMR_ENTREZID)
make_treeplot(FC_TCMR_ENTREZID)


```



### Selecting Genes Stable between Datasets

CPOP selects features that produce consistent effects between datasets irrespective of the noise. It starts by calculating pairwise log fold ratios by taking the pairwise differences between gene expression. The CPOP then uses a weighted Elastic Net regularised regression model to further select log fold ratios that are most stable between datasets. This improves the stability of the final model.

https://www.biorxiv.org/content/10.1101/2020.12.09.415927v1.full

https://sydneybiox.github.io/CPOP/articles/CPOP.html


```{r}

# Input two expression matrices, phenotype dataframes, significant genes, positive class (ABMR, TCMR)
# Output cpop result
get_cpop_result = function(exp_matrix1, exp_matrix2, pdata1, pdata2, genes_selected, positive_class){
  
  # Selects only significant genes from each expression matrix
  exp_matrix1_reduced = exp_matrix1[genes_selected,]
  exp_matrix2_reduced = exp_matrix2[genes_selected,]
  
  # Finds patients whom are either non-rejection or ABMR
  indx = which(pdata1$diagnosis == 'NR' | pdata1$diagnosis == positive_class)
  
  # Selects the correct patients from gene expression ratios & outcomes
  x1 = t(exp_matrix1_reduced[, indx])
  y1 = factor(pdata1$diagnosis[indx])
  
  indx = which(pdata2$diagnosis == 'NR' | pdata2$diagnosis == positive_class)
  
  x2 = t(exp_matrix2_reduced[, indx])
  y2 = factor(pdata2$diagnosis[indx])
  
  # Perform CPOP
  cpop_result = cpop_model(
  x1 = x1, x2 = x2,
  y1 = y1, y2 = y2,
  family = "binomial",
  alpha = 1,
  n_features = 10
  )
  
  # Find combined feature matrix
  features = bind_rows(data.frame(cpop_result$z1, check.names = FALSE), data.frame(cpop_result$z2, check.names = FALSE)) %>%
    dplyr::select(cpop_result$feature)
  
  return(list("cpop_result" = cpop_result, "features" =  features, "outcome" = c(y1, y2)))

}


```

#### CPOP on ABMR

```{r}

# Perform CPOP on expression matrices of ABMR vs Healthy and get stable pairwise gene ratios (features) and outcomes
abmr_cpop_results = get_cpop_result(eMat_GSE48581, eMat_GSE36059, p_GSE48581, p_GSE36059, genes_selected_ABMR, "ABMR")
 cpop_result = abmr_cpop_results$cpop_result
abmr_nonrej_features = abmr_cpop_results$features
abmr_nonrej_outcome = factor(abmr_cpop_results$outcome, levels = c("NR", "ABMR"))

# Plot network plot of stable pairwise gene ratios
plot_cpop(cpop_result = cpop_result, type = "ggraph")

```

#### CPOP on TCMR

```{r}

# Perform CPOP on expression matrices of TCMR vs Healthy and get stable pairwise gene ratios (features) and outcomes
tcmr_cpop_results = get_cpop_result(eMat_GSE48581, eMat_GSE36059, p_GSE48581, p_GSE36059, genes_selected_TCMR, "TCMR")
 cpop_result = tcmr_cpop_results$cpop_result
tcmr_nonrej_features = tcmr_cpop_results$features
tcmr_nonrej_outcome = factor(tcmr_cpop_results$outcome, levels = c("NR", "TCMR"))

# Plot network plot of stable pairwise gene ratios
plot_cpop(cpop_result = cpop_result, type = "ggraph")
tcmr_nonrej_features
```

## Model Building

### All Single Prediction Classifiers

These all return a prediction on a single test set of features.

Chosen based on the following thought process:

* Linear methods: Linear Discriminant Analysis and Logistic Regression.
* Non-Linear methods: Neural Network, SVM, kNN and Naive Bayes
* Trees and Rules: CART, J48 and PART
* Ensembles of Trees: C5.0, Bagged CART, Random Forest and Stochastic Gradient Boosting



```{r}

# Logistic Regression
log_pred = function(train_features, train_outcomes, test_features) {
  df = data.frame(cbind(train_features, "Outcome" = train_outcomes))
  log_reg = glm(Outcome ~ ., family = binomial(link = "logit"), data = df)
  prediction = predict(log_reg, data.frame(t(test_features)), type = "response")
  if (prediction <= 0.5) {
    classifier_prediction = levels(df$Outcome)[1]
  } else {
    classifier_prediction = levels(df$Outcome)[2]
  }
  return(classifier_prediction)
}

# kNN
knn_pred = function(train_features, train_outcomes, test_features){
  fit5 = class::knn(
        train = train_features,
        test = test_features,
        cl = train_outcomes,
        k=5
      )
  return(fit5)
}

# SVM
svm_pred = function(train_features, train_outcomes, test_features){
  svm_res = e1071::svm(x = train_features, y = as.factor(train_outcomes))
  classifier_prediction = predict(svm_res, data.frame(t(test_features)))
  return(classifier_prediction)
}

# Trees
tree_pred = function(train_features, train_outcomes, test_features){
  df = data.frame(cbind(train_features, "Outcome" = train_outcomes))
  rpart_res = rpart(Outcome ~ ., data = df)
  prediction = predict(rpart_res, data.frame(t(test_features)))
  classifier_prediction = colnames(prediction)[which(prediction == max(prediction))]
  return(classifier_prediction)
}


# Ensembles of Trees
rf_pred = function(train_features, train_outcomes, test_features){
  rf_res = randomForest::randomForest(x = train_features, y = as.factor(train_outcomes))
  classifier_prediction = predict(rf_res, test_features)
  return(classifier_prediction)
}


```

### PCA

```{r}

# Input CPOP pairwise feature matrix, outcome vector, test features, classifier prediction, class ("ABMR" or "TCMR")
# Output ggplotly object
# class_model = {"log", "svm", "tree", "rf", "knn"}

get_PCA_plot = function(train_features, train_outcomes, test_features, positive_class, class_model) {
  
  # New x projections on rotated set of axes
  pca_df = prcomp(train_features, retx = TRUE)
  # Get variance explained by PC1
  PC1_var = round(summary(pca_df)$importance[2] * 100, 2)
  # Get variance explained by PC2
  PC2_var = round(summary(pca_df)$importance[5] * 100, 2)
  # Get PCA of test features
  PCA_pred = predict(pca_df, t(test_features))
  
  # Get classifier prediction
  # Calling function using class_model variable name
  classifier_prediction = do.call(paste(class_model, "_pred", sep=''), list(train_features, train_outcomes, test_features))
  
    
  # Proper names for classifiers
  classifier_names = as.data.frame(matrix(
    c("log", "svm", "tree", "rf", "knn", "by Logistic Regression",
      "by Simple Vector Machine", "by Decision Tree", "by Random Forest", "by KNN"),
    ncol = 2, byrow=FALSE))
  
  classifier_name = classifier_names$V2[classifier_names$V1 == class_model]
  
  
  # Create plot dataframe with test patient
  Outcome = c(paste("Predicted as", as.character(classifier_prediction), classifier_name))
  PCA_pred_classified = cbind(PCA_pred, Outcome)
  pca_plot_df = data.frame(pca_df$x) %>%
    cbind("Outcome" = train_outcomes) %>%
    rbind(., "Test_Patient" = PCA_pred_classified)

  
  # Custom color palette
  rej_healthy_col = c("#4daf4a", "#E41A1C", "#377eb8")
  names(rej_healthy_col) = c("NR", positive_class, paste("Predicted as", as.character(classifier_prediction), classifier_name))
  
  # Create PCA plot with annotated prediction from classifier
  p = ggplot(pca_plot_df,
       aes(x=as.numeric(PC1),
           y=as.numeric(PC2),
           color=Outcome
           )) +
  geom_point(alpha=0.7) +
  scale_color_manual(values = rej_healthy_col) +
  theme_bw() +
  labs(title = paste("PCA of Pairwise Gene Expression by Kidney Graft Outcome (", positive_class, "vs No Rejection )"), 
       color = "Outcome",
       x = paste("PC1", " (", PC1_var,"%)", sep=""),
       y = paste("PC2", " (", PC2_var,"%)", sep=""))

  return(ggplotly(p))
}

# Example of using the get_PCA_plot function
# You may pass any of the following as class_model = {"log", "svm", "rpart", "rf", "knn"}
# It will use the respective model to make a prediction on the test data and plot it on the PCA graph
get_PCA_plot(tcmr_nonrej_features, tcmr_nonrej_outcome, test_tcmr_nonrej, "TCMR", "log")
get_PCA_plot(abmr_nonrej_features, abmr_nonrej_outcome, test_abmr_nonrej, "ABMR", "knn")


```

### Repeated Cross Validation

A generic cross-validation function.

```{r}

# n: number of samples
# cvK: fold number
# n_sim: number of repeats

cross_validation = function(n, cvK, n_sim, X, y){
  
  cv_rep_acc_log = cv_rep_acc_knn = cv_rep_acc_svm = cv_rep_acc_tree = cv_rep_acc_rf = c()
  
  for (i in 1:n_sim) {
    cvSets =  cvTools::cvFolds(n, cvK)  # permute all the data, into 5 folds
    cv_acc_log = cv_acc_knn = cv_acc_svm = cv_acc_tree = cv_acc_rf = c()
  
    for (j in 1:cvK) {
      test_id = cvSets$subsets[cvSets$which == j]
      X_test = X[test_id, ]
      X_train = X[-test_id, ]
      y_test = y[test_id]
      y_train = y[-test_id]
      
      ## Binary Logistic
      df = as.data.frame(cbind(X_train, "Outcome" = y_train))
      log_reg = glm(Outcome ~ ., family = binomial(link = "logit"), data = df)
      responses = predict(log_reg, X_test, type = "response")
      preds = sapply(responses, function(x){
        if (x <= 0.5) {
          levels(df$Outcome)[1]
        } else {
          levels(df$Outcome)[2]
        }
      })
      cv_acc_log[j] = mean(y_test == preds)
      
      ## KNN - 5 Nearest Neighbours
      fit5 = class::knn(
        train = X_train,
        test = X_test,
        cl = y_train,
        k=5
      )
      cv_acc_knn[j] = mean(y_test == fit5)
      
      ## SVM
      svm_res = e1071::svm(x = X_train, y = as.factor(y_train))
      fit = predict(svm_res, X_test)
      cv_acc_svm[j] = mean(y_test == fit)
      
      ## Trees
      
      #df = as.data.frame(cbind(X_train, "Outcome" = y_train))
      rpart_res = rpart(Outcome ~ ., data = df)
      prediction = predict(rpart_res, X_test)
      levels = colnames(prediction)
      preds = apply(prediction, 1, function(x){
        levels[which(x == max(x))]
      })
      cv_acc_tree[j] = mean(y_test == preds)
      
      
      #classifier_prediction = colnames(prediction)[which(prediction == max(prediction))]
      #return(classifier_prediction)
  
      ## Random Forest
      rf_res = randomForest::randomForest(x = X_train, y = as.factor(y_train))
      fit = predict(rf_res, X_test)
      cv_acc_rf[j] = mean(y_test == fit)
      
    }
    cv_rep_acc_log = append(cv_rep_acc_log, mean(cv_acc_log))
    cv_rep_acc_knn = append(cv_rep_acc_knn, mean(cv_acc_knn))
    cv_rep_acc_svm = append(cv_rep_acc_svm, mean(cv_acc_svm))
    cv_rep_acc_tree = append(cv_rep_acc_tree, mean(cv_acc_tree))
    cv_rep_acc_rf = append(cv_rep_acc_rf, mean(cv_acc_rf))
  }
  return(cbind(cv_rep_acc_log, cv_rep_acc_knn, cv_rep_acc_svm, cv_rep_acc_tree, cv_rep_acc_rf))
}

```


```{r}

# Calls cross-validation function and then plots results

get_cross_val_plot = function(n, cvK, n_sim, X, y) {
  
  # Get cross validation accuracy
  acc = cross_validation(n, cvK, n_sim, X, y)
  acc = as.data.frame(acc)
  
  # Positive class either TCMR or ABMR
  positive_class = levels(y)[2]
  
  # For pretty renaming
  names(acc) = c("Logistic Regression", "k-Nearest-Neighbours", "Simple Vector Machine", "Tree", "Random Forest")
  
  # Producing boxplot
  acc %>%
    pivot_longer(cols = 1:5,
                 names_to = "Classifier",
                 values_to = "Accuracy") %>%
    ggplot() +
    aes(x = Classifier,
        y = Accuracy) +
    geom_boxplot() +
    theme_bw() +
    labs(
      title = paste("Accuracy Comparison of Classifiers on Distinguishing", positive_class, "vs Non-Rejection"),
      subtitle = "Repeated 5-fold Cross Validation (N=10)",
      xlab = "Classifiers",
      ylab = "Accuracy"
    )

}

```

Using the `get_cross_val_plot`

```{r}
cvK = 5
n_sim = 10
X = tcmr_nonrej_features
y = tcmr_nonrej_outcome
n = nrow(X)

get_cross_val_plot(n, cvK, n_sim, X, y)

```

### Precision Recall Curve

Getting all the class probabilities in a matrix. In preparation for an PR-AUC curve.

```{r}

get_cv_class_probs = function(n, cvK, nsim, X, y){
  
  # Set positive class "TCMR" or "ABMR"
  positive_class = levels(y)[2]
  
  preds_df = data.frame()
  for (i in 1:nsim) {
    # Permute all the data, into 5 folds
    cvSets =  cvTools::cvFolds(n, cvK)  
    
    for (j in 1:cvK) {
      
      test_id = cvSets$subsets[cvSets$which == j]
      X_test = X[test_id, ]
      X_train = X[-test_id, ]
      y_test = y[test_id]
      y_train = y[-test_id]
      
      # For classifiers that require a dataframe
      df = as.data.frame(cbind(X_train, "Outcome" = y_train))
      
      
      # Logistic Regression
      log_reg = glm(Outcome ~ ., family = binomial(link = "logit"), data = df)
      log_responses = predict(log_reg, X_test, type = "response")
      
      # KNN
      knn5 = caret::knn3Train(X_train, X_test, as.factor(y_train), k=5, prob = TRUE)
      knn5_responses = attr(knn5,"prob")[,positive_class]
  
      # SVM
      svm_res = e1071::svm(x = X_train, y = as.factor(y_train), probability=TRUE)
      svm_preds = predict(svm_res, X_test, probability=TRUE)
      svm_responses = attr(svm_preds, "probabilities")[,positive_class]
      
      # Tree
      rpart_res = rpart(Outcome ~ ., data = df)
      rpart_preds = predict(rpart_res, X_test)
      rpart_responses = rpart_preds[,positive_class]
      
      # Random Forest
      rf_res = randomForest::randomForest(x = X_train, y = as.factor(y_train), keep.forest=TRUE)
      rf_preds = predict(rf_res, X_test, type="prob")
      rf_responses = rf_preds[,positive_class]
      
      matrix = cbind("patient_id" = rownames(X_test), 
                     "nsim" = rep(i, length(y_test)),
                     "fold_id" = rep(j, length(y_test)),
                     "truth" = as.factor(y_test),
                     "log" = log_responses,
                     "knn" = knn5_responses,
                     "svm" = svm_responses,
                     "rpart" = rpart_responses,
                     "rf" = rf_responses)
      
      preds_df = rbind(preds_df, matrix)
    }
  }
  return(preds_df)
}

```

```{r}



# X is train features
# y is train outcomes
# cvK is number of folds
# nsim is repeats

get_pr_plot = function(cvK, nsim, X, y){
  
  n = nrow(X)
  
  # Set positive class "TCMR" or "ABMR"
  positive_class = levels(y)[2]
  
  # Get repeated, cross-validated class probabilities of positive class
  cv_class_probs = get_cv_class_probs (n, cvK, nsim, X, y)
  
  # Get mean probabilities of different classifiers
  mean_class_probs = cv_class_probs %>% 
    group_by(patient_id) %>%
    summarise(truth = as.factor(max(as.integer(truth))),
              LogisticRegression = mean(as.double(log)),
              KNN = mean(as.double(knn)),
              SVM = mean(as.double(svm)),
              DecisionTree = mean(as.double(rpart)),
              RandomForest = mean(as.double(rf)))
  
  # Restructuring for use with yardstick pr_curve function
  mean_class_probs_long = mean_class_probs %>%
    dplyr::select(-patient_id) %>%
    pivot_longer(
      cols = 2:6,
      names_to = "Classifier",
      values_to = "Probability"
    )
  
  # Generate PR curve
  precision_recall_curve = mean_class_probs_long %>%
    group_by(Classifier) %>%
    pr_curve(
           truth = truth,
           Probability,
           event_level = "second"
           ) %>%
    ggplot() +
    aes(x = recall,
        y = precision,
        color = Classifier) +
    geom_path() +
    coord_equal() +
    theme_bw() +
    labs(
      title = paste("PR Comparison of Different Classifiers for", positive_class),
      subtitle = "Repeated 5-fold Cross Validation (N=10)",
      x = "Recall",
      y = "Precision"
    )
  
  pr_auc = mean_class_probs_long %>%
    group_by(Classifier) %>%
    pr_auc(truth, Probability)
  
  return(list("pr_curve" = precision_recall_curve, "pr_auc" = pr_auc))
}


  
```

```{r}

# Get Precision Recall Curves

pr_tcmr = get_pr_plot(cvK = 5,
                      nsim = 10,
                      X = tcmr_nonrej_features,
                      y = tcmr_nonrej_outcome)
pr_tcmr$pr_curve
pr_tcmr$pr_auc


pr_abmr = get_pr_plot(cvK = 5,
                      nsim = 10,
                      X = abmr_nonrej_features,
                      y = abmr_nonrej_outcome)

pr_abmr$pr_curve
pr_abmr$pr_auc

```

### Subsetting for Stability of Feature Selection

```{r}


# Input two expression matrices, two patient data, proportion of data to sample
# Output ABMR and TCMR features -> CPOP features
get_subsetted_features = function(eMat1, eMat2, p1, p2, split_prop){
  
  # Stratification of Dataset so there is TCMR, ABMR, NR present in same proportions as original
  p1_positive_TCMR = p1[which(p1$diagnosis == "TCMR"),]
  p1_positive_ABMR = p1[which(p1$diagnosis == "ABMR"),]
  p1_negative = p1[which(p1$diagnosis == "NR"),]
  
  p2_positive_TCMR = p2[which(p2$diagnosis == "TCMR"),]
  p2_positive_ABMR = p2[which(p2$diagnosis == "ABMR"),]
  p2_negative = p2[which(p2$diagnosis == "NR"),]
  
  # Random sampling of subset of dataset (pData and expression matrix)
  rand_p1_positive_TCMR = slice_sample(p1_positive_TCMR, prop = split_prop)
  rand_p1_positive_ABMR = slice_sample(p1_positive_ABMR, prop = split_prop)
  rand_p1_negative = slice_sample(p1_negative, prop = split_prop)
  p1_combined = rbind(rand_p1_positive_TCMR, rand_p1_positive_ABMR, rand_p1_negative)
  eMat1_combined = eMat1[, rownames(p1_combined)]
  
  
  rand_p2_positive_TCMR = slice_sample(p2_positive_TCMR, prop = split_prop)
  rand_p2_positive_ABMR = slice_sample(p2_positive_ABMR, prop = split_prop)
  rand_p2_negative = slice_sample(p2_negative, prop = split_prop)
  p2_combined = rbind(rand_p2_positive_TCMR, rand_p2_positive_ABMR, rand_p2_negative)
  eMat2_combined = eMat2[, rownames(p2_combined)]
  
  # Finding DE genes and taking intersection between two subsets
  sig_genes_1_TCMR = get_ORA_genes(p1_combined, eMat1_combined)$tT_TCMR
  sig_genes_2_TCMR = get_ORA_genes(p2_combined, eMat2_combined)$tT_TCMR
  
  sig_genes_1_ABMR = get_ORA_genes(p1_combined, eMat1_combined)$tT_ABMR
  sig_genes_2_ABMR = get_ORA_genes(p2_combined, eMat2_combined)$tT_ABMR
  
  
  # Find intersection of genes
  sig_genes_TCMR = intersect(rownames(sig_genes_1_TCMR), rownames(sig_genes_2_TCMR))
  sig_genes_ABMR = intersect(rownames(sig_genes_1_ABMR), rownames(sig_genes_2_ABMR))
  
  # Apply CPOP on subsets
  abmr_cpop_results = get_cpop_result(eMat1_combined, eMat2_combined, p1_combined, p2_combined,   sig_genes_ABMR, "ABMR")
  tcmr_cpop_results = get_cpop_result(eMat1_combined, eMat2_combined, p1_combined, p2_combined,   sig_genes_TCMR, "TCMR")
  
  cpop_result_abmr = abmr_cpop_results$cpop_result
  cpop_result_tcmr = tcmr_cpop_results$cpop_result
  
  return(list("ABMR" = cpop_result_abmr$feature, "TCMR" = cpop_result_tcmr$feature))
}

```


```{r}

v1 = c("CDH5--MMRN2",    "CXCL9--IL15RA",  "HLA-A--IL1B",    "HLA-DRB1--SOST", "IRF1--VWF",      "KLF4--NOS3",    
  "MALL--NKG7",     "APOL1--HYAL2",   "C1orf162--VWF",  "CRHBP--HYAL2",   "ESM1--GNG11",    "FCN3--PSMB8",   
  "GBP4--HLA-DMB",  "HCK--HLA-F",     "HCP5--HLA-C",    "IDO1--KLRB1"   )
print(v1)
v2 = c("CDH5--MMRN2",       "CFP--KLRB1",        "CXCL10--VAMP5",     "LYN--TCRDV2",       "VEGFC--VWF",       
       "ACSL5--CXCL9",      "C1orf162--VEGFC",   "CFP--TM4SF18",      "ECSCR--IL15",       "GBP4--HLA-DMB",    
       "HLA-DQB1--RARRES3", "HLA-DRA--TRDV3",    "IL15RA--PSMB8",     "KLRD1--LST1"   )
union(v1, v2)
length(union(v1, v2))

get_jaccard = function(v1, v2) {
    intersect_length = length(intersect(v1, v2))
    #print(paste("Intersect Length", intersect_length))
    union_length = length(v1) + length(v2) - intersect_length
    #print(paste("Union Length", union_length))
    jaccard_index = intersect_length/union_length
    return (as.double(jaccard_index))
}

ABMR_features = list()
TCMR_features = list()

for (i in 1:10) {
  subsetted_features = get_subsetted_features (eMat1 = eMat_GSE36059, 
                                               eMat2 = eMat_GSE48581, 
                                               p1 = p_GSE36059, 
                                               p2 = p_GSE48581,
                                               split_prop = 0.95)
  ABMR_features[i] = subsetted_features[1]
  TCMR_features[i] = subsetted_features[2]
  
}

jaccard_indexes_abmr = c()
jaccard_indexes_tcmr = c()
cmb = t(combn(length(ABMR_features), 2))
for (i in 1:nrow(cmb)){
  jaccard_index_abmr = get_jaccard(ABMR_features[[cmb[i,1]]], ABMR_features[[cmb[i,2]]])
  jaccard_indexes_abmr = append(jaccard_indexes_abmr, jaccard_index_abmr)
  jaccard_index_tcmr = get_jaccard(TCMR_features[[cmb[i,1]]], TCMR_features[[cmb[i,2]]])
  jaccard_indexes_tcmr = append(jaccard_indexes_tcmr, jaccard_index_tcmr)
}

jaccard_indexes = cbind("ABMR" = jaccard_indexes_abmr, "TCMR" = jaccard_indexes_tcmr)
as.data.frame(jaccard_indexes) %>%
  pivot_longer(1:2, names_to = "Condition", values_to = "Jaccard Index") %>%
  ggplot() +
  aes(x = Condition,
      y = `Jaccard Index`) +
  geom_boxplot() +
  theme_bw() +
  labs(
    title = "Similarity of Selected Pairwise Features from Subsetted Data", 
    subtitle = "Jaccard Index from Repeated Randomised Subsampling (N=10)",
    caption = str_wrap("Random 95% slices of original gene datasets GSE36059 & GSE48581 were subsampled with stratification i.e. proportion of factor levels equal to original dataset. CPOP was applied to find significant pairwise gene features. This was repeated (N=10) and a Jaccard similarity index was calculated for every combination of subsamples. It appears the gene selection process is not stable.") 
  )


boxplot(jaccard_indexes)


#for (i in 2:4){
#  print(i)
#}
#
#jaccard_indexes
#
#
#ABMR_features
#TCMR_features
#
#sum(p1$diagnosis == 'TCMR')
#sum(p2$diagnosis == 'TCMR')
```

We can use an ensemble of different classifiers and take the median probability to generate a more stable prediction. Stability of your model/process is particularly important.

Methods section: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5470931/

We can potentially include a penalty for the comorbidities present in the transplant recipient by using the Charlson Comorbidity Score. However I can't find a dataset for this yet.
https://pubmed.ncbi.nlm.nih.gov/29731067/

* Linear methods: Linear Discriminant Analysis and Logistic Regression.
* Non-Linear methods: Neural Network, SVM, kNN and Naive Bayes
* Trees and Rules: CART, J48 and PART
* Ensembles of Trees: C5.0, Bagged CART, Random Forest and Stochastic Gradient Boosting
https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-017-1925-0


## Model Evaluation

Clear description of the approach in data collection, developed model, the evaluation strategies from a data-science perspective. Here we refer to all types of evaluation metrics including graphical, qualitative and quantitative metric.

A clear justification of the final approach based on the proposed evaluation strategies. Ensuring multiple evaluation strategies are used.

Accuracy

* Cross-Validation
* PRC-AUC Curve

Stability

* Stability on datasets with ABMR
* Stability vs Accuracy (Stability evaluated on original datasets)
* Progressively adding more noise to the original dataset and observing model performance (maybe an overlay of line plots)

Interpretability

* Depth of tree versus cross-validated accuracy

Fairness

* Gender
Significant Genes between Gender: https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0004802#pone.0004802.s005

Justification for PRC-AUC: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4349800/
Interpretability: https://christophm.github.io/interpretable-ml-book/scope-of-interpretability.html

### Test Dataset to Pairwise Gene Differences

```{r}

# Affymetrix to Gene Symbol Mapping depends on # Initial Data Ingestion
AFFX_gene_symbols

# Ingesting Test Case
test_case_probe_id = read.csv('example_gene_input.csv')



# Input feature names df from CPOP, test_case with probe ID & expression
# Output feature vector of relevant pairwise differences
get_pairwise_differences_probe_id = function(features, test_case_probe_id){
  colnames(test_case_probe_id) = c('probe_id', 'expr')
  
  feature_names = data.frame(names(features)) %>%
    tidyr::separate(`names.features.`,c("from", "to"), "--")
  
  
  feature_differences = feature_names %>%
    dplyr::select(from, to) %>%
    apply(., 1, function(x){
      from = AFFX_gene_symbols$ID[AFFX_gene_symbols$`Gene Symbol` == x[1]]
      to = AFFX_gene_symbols$ID[AFFX_gene_symbols$`Gene Symbol` == x[2]]
      return(test_case_probe_id$expr[test_case_probe_id$probe_id == from] - test_case_probe_id$expr[test_case_probe_id$probe_id == to])
    })
  
  names(feature_differences) = names(features)
  
  return(feature_differences)
}

# Input feature names df from CPOP, test_case with gene symbol & expression
# Output feature vector of relevant pairwise differences
get_pairwise_differences_gene_symbol = function(features, test_case_gene_symbol){
  colnames(test_case_gene_symbol) = c('gene_symbol', 'expr')
  
  feature_names = data.frame(names(features)) %>%
    tidyr::separate(`names.features.`,c("from", "to"), "--")
  
  feature_differences = feature_names %>%
    dplyr::select(from, to) %>%
    apply(., 1, function(x){
      from = test_case_gene_symbol$expr[test_case_gene_symbol$gene_symbol == x[1]]
      to = test_case_gene_symbol$expr[test_case_gene_symbol$gene_symbol == x[2]]
      return(as.numeric(from)-as.numeric(to))
    })
  names(feature_differences) = colnames(features)
  
  return(feature_differences)
}




```

```{r}

# For Probe ID inputs
test_tcmr_nonrej = get_pairwise_differences_probe_id (tcmr_nonrej_features, test_case_probe_id)
test_abmr_nonrej = get_pairwise_differences_probe_id (abmr_nonrej_features, test_case_probe_id)
# For Gene Symbol inputs
test_tcmr_nonrej = get_pairwise_differences_gene_symbol(tcmr_nonrej_features, example_slider_input)
test_abmr_nonrej = get_pairwise_differences_gene_symbol(abmr_nonrej_features, example_slider_input)

# Example TCMR input
example_slider_input = as.data.frame(
  cbind(c("APOBEC3G", "CD72", "C1orf162", "HAPLN3", "IDO1", 
                          "SELPLG", "IRF1", "GBP5", "PSMB8", "LCP2", "TNFRSF1B", 
                          "MYB", "TAP1" ,"TRIM69", "VAV1", "TNFRSF9", "CD8A", "LST1"),
        c(9.80811398, 6.039011785, 5.810845604, 10.34278117, 3.211123348, 
                   7.615630883, 5.473263969, 5.130847382, 5.967406954, 3.806599082, 
                   6.459728547, 8.52547126, 6.155345118, 6.431330609, 6.973053399, 
                   4.590544467, 5.997751859, 4.27406608)))
```

```{r}
get_genes_for_sliders = function(features){
  names(features) %>%
  sapply(., function(x){str_split(x,'--')}) %>%
  unlist() %>%
  unique()
}

```

```{r}

get_genes_for_sliders(tcmr_nonrej_features)
get_genes_for_sliders(abmr_nonrej_features)



```






## Model Interpretation
```{r}
pima
```




## Junk Code

### GSE21374

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2877953/

This paper which the dataset belongs to, created a molecular classifier for predicting future graft loss. It also has a time to failure/census which is quite good.

```{r}
GSE21374 = getGEO("GSE21374")
GSE21374 = GSE21374$GSE21374_series_matrix.txt.gz

eMat_GSE21374 = exprs(GSE21374)
rownames(eMat_GSE21374)
length(rownames(eMat_GSE21374))
fData(GSE21374)$`Gene Symbol`
pData(GSE21374)
```

### GSE98320

This dataset has 1208 samples. The clustering contains information about the predicted category of the kidney transplant based on microarray data.

Important to note that this dataset contains samples from GSE36059 & GSE48581 (See Methods of Paper below)
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5470931/

This dataset also uses a slightly different platform GPL15207 and matching on the Gene Symbol shows that there are 17344 genes matching between this dataset and all the other datasets on a platform GPL570.

In terms of the clustering in order they are: No Rejection, TCMR, ABMR, early-stage ABMR, fully-developed ABMR, late-stage ABMR
*  

```{r}
GSE98320 = getGEO("GSE98320")
GSE98320 = GSE98320$GSE98320_series_matrix.txt.gz

fData(GSE98320)$`Gene Symbol`

length(intersect(fData(GSE98320)$`Gene Symbol`, fData(GSE21374)$`Gene Symbol`))
length(fData(GSE21374)$`Gene Symbol`)
length(fData(GSE98320)$`Gene Symbol`)

eMat_GSE98320 = exprs(GSE98320)
pData(GSE98320)
dim(eMat_GSE98320)
```

### GSE34748

Transplant glomerulopathy can be attributed to ABMR as it is a histological sign of chronic tissue injury. The reference is below.
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8503253/

Here the dataset contains data on 20 patients with transplant glomerulopathy which we will add as ABMR replicates.

We have treated the control biopsies as no rejection as within this study, there were no circulating donor specific antibodies (DSA) after transplantation. It is possible that the immunosuppressive regime that the patient underwent may mask the diagnosis of TCMR. However, 

```{r}

GSE34748 = getGEO("GSE34748")
GSE34748 = GSE34748$GSE34748_series_matrix.txt.gz
GSE34748
pData(GSE34748)$title
```

### GSE51675

```{r}

GSE51675 = getGEO("GSE51675")

```

#### Highest Variability

This is an alternative method to select genes.

```{r}
# High Variability

large_var_GSE48581 = apply(eMat_GSE48581, 1, var)
large_var_GSE36059 = apply(eMat_GSE36059, 1, var)

# Top 50 genes by variance
GSE48581_top50 = names(tail(sort(large_var_GSE48581), 50))
GSE36059_top50 = names(tail(sort(large_var_GSE36059), 50))
setdiff(GSE48581_top50, GSE36059_top50)
genes_selected = intersect(GSE48581_top50, GSE36059_top50)


#ind_GSE46474 = tail(order(large_var_GSE46474), 50) 

```



DisGeNET is a database of gene-disease associations.
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5210640/



### Pairwise Expression Ratios

Justification for pairwise expression ratios.
https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2261-8

This code is technically not used at the moment since the package CPOP already calculates pairwise differences i.e. log fold ratios for us, however I think it is good to have here since we need to manually calculate log-fold ratios for new inferences.

https://stackoverflow.com/questions/27489193/pairwise-row-matrix-multiplication-in-r

The following code produces a list of vectors of combinations of two probes, then takes the difference in gene expression for each pair
`lapply(split(indx, col(indx)), function(x) eMat_GSE48581_reduced[x[1],]-eMat_GSE48581_reduced[x[2],])`
The lapply spits out a separate row result for each combination of probes. Do.call with row bind, binds them all together into a matrix
`do.call(rbind, lapply(split(indx, col(indx)), function(x) eMat_GSE48581_reduced[x[1],]-eMat_GSE48581_reduced[x[2],]))`

```{r}
eMat_GSE48581_reduced = eMat_GSE48581[genes_selected,]
eMat_GSE36059_reduced = eMat_GSE36059[genes_selected,]


# This takes combinations of the different genes and finds the difference in their expression
indx = combn(rownames(eMat_GSE48581_reduced),2)
combn_names = paste(t(indx)[,1], t(indx)[,2], sep='--')
eMat_GSE48581_ratios = cbind(combn_names, as.data.frame(do.call(rbind, lapply(split(indx, col(indx)), function(x) eMat_GSE48581_reduced[x[1],]-eMat_GSE48581_reduced[x[2],]))))
eMat_GSE48581_ratios = eMat_GSE48581_ratios %>% remove_rownames %>% column_to_rownames(var = "combn_names")

indx = combn(rownames(eMat_GSE36059_reduced),2)
eMat_GSE36059_ratios = cbind(combn_names, as.data.frame(do.call(rbind, lapply(split(indx, col(indx)), function(x) eMat_GSE36059_reduced[x[1],]-eMat_GSE36059_reduced[x[2],]))))
eMat_GSE36059_ratios = eMat_GSE36059_ratios %>% remove_rownames %>% column_to_rownames(var = "combn_names")

eMat_GSE48581_ratios
eMat_GSE36059_ratios

```



Junk EnrichKEGG code

```{r}

# Combined datasets into matrix
eMat_combined = cbind(eMat_GSE48581, eMat_GSE36059)

# Get only genes relevant to ABMR and TCMR respectively
eMat_combined_ABMR = eMat_combined[genes_selected_ABMR,]
eMat_combined_TCMR = eMat_combined[genes_selected_TCMR,]
# Get 
FC_TCMR = tT_TCMR[genes_selected_TCMR,]
FC_ABMR = tT_ABMR[genes_selected_ABMR,]

# Biological ID Translator
# Get ABMR genes
translated_ABMR = bitr(rownames(eMat_combined_ABMR),
     fromType = "SYMBOL",
     toType = "ENTREZID",
     OrgDb = "org.Hs.eg.db"
     )

# Get TCMR genes
translated_TCMR = bitr(rownames(eMat_combined_TCMR),
     fromType = "SYMBOL",
     toType = "ENTREZID",
     OrgDb = "org.Hs.eg.db"
     )

# Get gene list with ENTREZID

FC_ABMR_ENTREZID = FC_ABMR %>% 
  dplyr::select(logFC) %>% 
  filter(row.names(tT_ABMR) %in% translated_ABMR$SYMBOL)

row.names(tT_ABMR) %in% translated_ABMR$SYMBOL
row.names(FC_ABMR_ENTREZID) = translated_ABMR$ENTREZID

#UNSOLVED WHY THE FUCK IS THERE ONE EXTRA INDEX
FC_TCMR_ENTREZID = FC_TCMR %>% 
  dplyr::select(logFC) %>% 
  filter(row.names(tT_TCMR) %in% translated_TCMR$SYMBOL)
  
row.names(FC_TCMR_ENTREZID) = translated_TCMR$ENTREZID

# Get combined expression matrix with ENTREZID
eMat_combined_ABMR_ENTREZID = eMat_combined_ABMR[which(rownames(eMat_combined_ABMR) %in% translated_ABMR$SYMBOL), ]
rownames(eMat_combined_ABMR_ENTREZID) = translated_ABMR$ENTREZID

#UNSOLVED WHY THE FUCK IS THERE ONE EXTRA INDEX
eMat_combined_TCMR_ENTREZID = eMat_combined_TCMR[which(rownames(eMat_combined_TCMR) %in% translated_TCMR$SYMBOL), ]
rownames(eMat_combined_TCMR_ENTREZID) = translated_TCMR$ENTREZID






bitr(rownames(eMat_combined_ABMR_ENTREZID),
     fromType = "SYMBOL",
     toType = "ENTREZID",
     OrgDb = "org.Hs.eg.db"
     )

sum(duplicated(translated_TCMR$ENTREZID))


```


## Explainability

```{r}
# Required package for biomaRt
# BiocManager::install("biomaRt")
library(biomaRt)
ensembl = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl
GB_ACC = fData(GSE36059)$GB_ACC
dat = getBM(attributes = c("protein_id", "embl", "hgnc_symbol"), values = GB_ACC, mart = ensembl)


```


This library helps with the explainability by showing the molecular pathway that a gene is related to.

```{r}
library(msigdbr)

# Get all species in this database
msigdbr_species()

# All gene sets of a humans
all_gene_sets = msigdbr(species = "Homo sapiens")

all_gene_sets %>%
  filter(human_gene_symbol == "M87338")
head(all_gene_sets)
```



VIS

Autoencoder, not effective, don't run

```{r}
library(keras)
library(tensorflow)
library(tidyverse)

x_train <- as.matrix(abmr_nonrej_features)

model <- keras_model_sequential()

model %>% 
  layer_dense(units = 6, activation = "tanh", input_shape = ncol(x_train)) %>%
  layer_dense(units = 2, activation = "tanh", name = "bottleneck") %>% 
  layer_dense(units = 6, activation = "tanh") %>% 
  layer_dense(units = ncol(x_train))

summary(model)

intermediate <- keras_model(inputs = model$input, outputs = get_layer(model, "bottleneck")$output)
intermediate_output <- predict(intermediate, x_train)

ggplot(data.frame(PC1 = intermediate_output[,1], PC2 = intermediate_output[,2]), aes(x=PC1, y = PC2, col=abmr_nonrej_outcome)) + geom_point(size=0.75)

#pca_plotly <- plot_ly(data.frame(PC1 = intermediate_output[,1], PC2 = intermediate_output[,2], PC3 = intermediate_output[,3]), x = ~PC1, y = ~PC2, z = ~PC3, color = ~abmr_nonrej_outcome, colors = c("#BF382A", "#0C4B8E"))
#pca_plotly
```

PCA, somewhat ok plot

```{r}
library(factoextra)
library(plotly)
library(DAAG)
library(FactoMineR)
library(scatterplot3d)
library(ggforce)

res.pca <- prcomp(abmr_nonrej_features)

fviz_screeplot(res.pca, ncp=10)

df_toplot <- data.frame(abmr_nonrej_outcome, 
                        pc1 = res.pca$x[,1], pc2 = res.pca$x[,2])

g <- ggplot(df_toplot, aes(x = pc1, y = pc2, color = abmr_nonrej_outcome)) + 
  geom_point(size = 0.75) + 
  theme_minimal()
g

# colors = c("#BF382A", "#0C4B8E")
# colors <- colors[as.numeric(abmr_nonrej_outcome)]
# pca_plotly <- scatterplot3d(res.pca$x[,1:3], color = colors, box = FALSE, pch = 16) 

pca_plotly <- plot_ly(as.data.frame(res.pca$x), x = ~PC1, y = ~PC2, z = ~PC3, color = ~abmr_nonrej_outcome, colors = c("#BF382A", "#0C4B8E"))
pca_plotly
```

UMAP!!

```{r}
library(umap)

abmr.umap = umap(abmr_nonrej_features)

ggplot(data.frame(pc1 = abmr.umap$layout[,1], pc2 = abmr.umap$layout[,2]), aes(x = pc1, y = pc2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)
```

t-SNE

```{r}
#library(Rtsne)
#library(ggpubr)
set.seed(42)

tSNE_fit <- as.matrix(abmr_nonrej_features) %>% normalize_input() %>% Rtsne(perplexity = 200)

tSNE_df <- tSNE_fit$Y %>% 
  as.data.frame() %>%
  dplyr::rename(tSNE1="V1",
         tSNE2="V2")

a <- ggplot(tSNE_df, aes(x = tSNE1, y = tSNE2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)
a
```

kernel pca

```{r}
library(kernlab)

nonlinear_pca <- kpca(as.matrix(abmr_nonrej_features), kernel = "rbfdot", kpar = list(sigma = 0.01), features = 2, th = 1e-4)

to.plot = as.data.frame(rotated(nonlinear_pca))

b <- ggplot(to.plot, aes(x = V1, y = V2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)
b

nonlinear_pca <- kpca(as.matrix(abmr_nonrej_features), kernel = "rbfdot", kpar = list(sigma = 0.01), features = 3, th = 1e-4)

to.plot = as.data.frame(rotated(nonlinear_pca))

pca_plotly <- plot_ly(to.plot, x = ~V1, y = ~V2, z = ~V3, color = ~abmr_nonrej_outcome, colors = c("#BF382A", "#0C4B8E"))
pca_plotly

```

testing others

```{r}
tSNE_fit <- as.matrix(abmr_nonrej_features)  %>% normalize_input() %>% Rtsne(perplexity = 10)

tSNE_df <- tSNE_fit$Y %>% 
  as.data.frame() %>%
  dplyr::rename(tSNE1="V1",
         tSNE2="V2")

b <- ggplot(tSNE_df, aes(x = tSNE1, y = tSNE2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)


tSNE_fit <- as.matrix(abmr_nonrej_features)  %>% normalize_input() %>% Rtsne(perplexity = 15)

tSNE_df <- tSNE_fit$Y %>% 
  as.data.frame() %>%
  dplyr::rename(tSNE1="V1",
         tSNE2="V2")

c <- ggplot(tSNE_df, aes(x = tSNE1, y = tSNE2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)


tSNE_fit <- as.matrix(abmr_nonrej_features)  %>% normalize_input() %>% Rtsne(perplexity = 20)

tSNE_df <- tSNE_fit$Y %>% 
  as.data.frame() %>%
  dplyr::rename(tSNE1="V1",
         tSNE2="V2")

d <- ggplot(tSNE_df, aes(x = tSNE1, y = tSNE2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)


tSNE_fit <- as.matrix(abmr_nonrej_features)  %>% normalize_input() %>% Rtsne(perplexity = 25)

tSNE_df <- tSNE_fit$Y %>% 
  as.data.frame() %>%
  dplyr::rename(tSNE1="V1",
         tSNE2="V2")

e <- ggplot(tSNE_df, aes(x = tSNE1, y = tSNE2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)


tSNE_fit <- as.matrix(abmr_nonrej_features)  %>% normalize_input() %>% Rtsne(perplexity = 30)

tSNE_df <- tSNE_fit$Y %>% 
  as.data.frame() %>%
  dplyr::rename(tSNE1="V1",
         tSNE2="V2")

f <- ggplot(tSNE_df, aes(x = tSNE1, y = tSNE2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)



tSNE_fit <- as.matrix(abmr_nonrej_features)  %>% normalize_input() %>% Rtsne(perplexity = 35)

tSNE_df <- tSNE_fit$Y %>% 
  as.data.frame() %>%
  dplyr::rename(tSNE1="V1",
         tSNE2="V2")

g <- ggplot(tSNE_df, aes(x = tSNE1, y = tSNE2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)



tSNE_fit <- as.matrix(abmr_nonrej_features)  %>% normalize_input() %>% Rtsne(perplexity = 40)

tSNE_df <- tSNE_fit$Y %>% 
  as.data.frame() %>%
  dplyr::rename(tSNE1="V1",
         tSNE2="V2")

h <- ggplot(tSNE_df, aes(x = tSNE1, y = tSNE2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)



tSNE_fit <- as.matrix(abmr_nonrej_features)  %>% normalize_input() %>% Rtsne(perplexity = 45)

tSNE_df <- tSNE_fit$Y %>% 
  as.data.frame() %>%
  dplyr::rename(tSNE1="V1",
         tSNE2="V2")

i <- ggplot(tSNE_df, aes(x = tSNE1, y = tSNE2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)




tSNE_fit <- as.matrix(abmr_nonrej_features)  %>% normalize_input() %>% Rtsne(perplexity = 50)

tSNE_df <- tSNE_fit$Y %>% 
  as.data.frame() %>%
  dplyr::rename(tSNE1="V1",
         tSNE2="V2")

j <- ggplot(tSNE_df, aes(x = tSNE1, y = tSNE2, color = abmr_nonrej_outcome)) + geom_point(size = 0.75)


ggarrange(a,b, labels = c("5", "10"), ncol = 1, nrow = 2)
ggarrange(c,d, labels = c("15", "20"), ncol = 1, nrow = 2)
ggarrange(e,f, labels = c("25", "30"), ncol = 1, nrow = 2)
ggarrange(g,h, labels = c("35", "40"), ncol = 1, nrow = 2)
ggarrange(i,j, labels = c("45", "50"), ncol = 1, nrow = 2) 

```



```{r}

PCA_pred = predict(pca_df, t(test_tcmr_nonrej))

Outcome = c(paste("Predicted as", as.character(classifier_prediction)))


PCA_pred_classified = cbind(PCA_pred, Outcome)

pca_plot_df = data.frame(pca_df$x) %>%
  cbind("Outcome" = tcmr_nonrej_outcome) %>%
  rbind(., "Test_Patient" = PCA_pred_classified)

rej_healthy_col = c("#4daf4a", "#E41A1C", "#377eb8")
names(rej_healthy_col) = c("NR", "TCMR", paste("Predicted as", as.character(classifier_prediction)))
p = ggplot(pca_plot_df,
       aes(x=as.numeric(PC1),
           y=as.numeric(PC2),
           color=Outcome
           )) +
  geom_point(alpha=0.7) +
  scale_color_manual(values = rej_healthy_col) +
  theme_bw() +
  labs(title = "PCA of Gene Expression by Kidney Transplant Outcome", 
       color = "Outcome",
       x = paste("PC1", " (", PC1_var,"%)", sep=""),
       y = paste("PC2", " (", PC2_var,"%)", sep=""))

ggplotly(p)



```