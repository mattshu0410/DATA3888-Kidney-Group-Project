---
title: "Main Analysis"
author: Matthew Shu; Raymond Huang; Hugo Ohlsson; Vasu Paliwal; Ruestam Bhangal; Jiani
  Tan
date: "03/04/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, results='hide', warning=FALSE, message=FALSE}
library(dplyr)
library(tidyr)
library(devtools)
library(ggplot2)
library(stringr)
library(stringdist)
library(GEOquery) 
library(R.utils)
library(Biobase)
library(reshape2)
library(ggplot2)
library(limma)
library(stats)
library(blorr)
library(viridis)
library(plotly)
library(ggrepel)
library(CPOP)
library(clusterProfiler)
library(DOSE)
library(org.Hs.eg.db)
library(pathview)
library(enrichplot)
library(msigdbr)
library(stringr)

#BiocManager::install("sva")
```

## Inspiration / Overall Focus

https://imageo.genyo.es/

The following is an excerpt from GSE36059 report. It outlines the clinical recommendations that could be made off the back of being able to differentiate TCMR from ABMR. It is important to note that these biopsies are taken post-transplant.

"
The significance of the AKI score is dictated by the inducing
insult, which can be:
(1) self-limited, for example, early AKI in kidney transplants;
(2) treatable, for example, TCMR;
(3) difficult to treat and sustained, for example, late ABMR
or recurrent glomerulonephritis.
The conclusion that progression in troubled transplants is
primarily a function of ongoing parenchymal injury, not
destructive fibrosis, has promising therapeutic implications:
if we can arrest the disease that is wounding nephrons (e.g.
ABMR) before the renal tissue is too badly damaged, the
kidney will stabilize. The corollary is that treatments directed
at arresting fibrosis may not be useful because they fail to
address the cause of parenchymal injury.
...

TCMR after treatment in experienced centers is not
associated with reduced graft survival if there is no ABMR,
although TCMR should always trigger a review of the
immunosuppressive drug (ISD) prescription and patient
adherence. 


"

How to treat ABMR 
https://pubmed.ncbi.nlm.nih.gov/31895348/

## Datasets Ingestion & Cleaning

### GSE36059

https://www.sciencedirect.com/science/article/pii/S0085253815561863#bb0095



Human leukocyte antigen (HLA) antibodies were initially recognised as responsible for the immediate, hyperacute rejection of kidney grafts. Later we began to distinguish between two more types of rejection.

*  TCMR (T-cell Mediated Rejection) 
*  ABMR (Antibody Mediated Rejection)

C4d is a complement component i.e. molecule that tends to build up in the peritubular capillaries of kidneys, and was found to be a hallmark of anti-body mediated rejection. ABMR could both affect patients immediately (those who were presensitised) or much later due to de novo DSA production i.e. their body starting producing new antibodies against the donor's tissue. Both would eventually end up in end-stage renal failure.

It seems that this research finds ABMR to be primarily linked to a high probability of end-stage renal failure whereas TCMR probability of renal failure actually decreases over time. Distinguishing these could provide crucial clinical details as timing is a major factor in decision making.

![image](https://ars.els-cdn.com/content/image/1-s2.0-S0085253815561863-gr1.jpg)
Entrez Gene ID are unique alphanumeric identifiers for genes and other loci.

```{r}
# Reading in Data
GEO_GSE36059 = getGEO("GSE36059")
GSE36059 = GEO_GSE36059$GSE36059_series_matrix.txt.gz

# Example of functions that return patient data, feature data, expression matrix
#head(pData(GSE36059)[,1:5])
#head(fData(GSE36059)[,1:5])
#head(exprs(GSE36059)[,1:5])

# How to return gene names
#rownames(eMat_GSE36059)
#length(rownames(eMat_GSE36059))

# Load relevant matrices
eMat_GSE36059 = exprs(GSE36059)
p_GSE36059 = dplyr::rename(pData(GSE36059), diagnosis = `diagnosis:ch1`)
p_GSE36059$diagnosis = gsub("non-rejecting", "NR", p_GSE36059$diagnosis)

# Rows & patient id with control diagnosis of nephrectomy
control_idx = which(p_GSE36059$diagnosis == "nephrectomy")
remove_patient_id = rownames(p_GSE36059)[control_idx]

# Remove controls from patient and expression dataset
p_GSE36059 = p_GSE36059[!(row.names(p_GSE36059) %in% remove_patient_id),]
eMat_GSE36059 = eMat_GSE36059[, !(colnames(eMat_GSE36059) %in% remove_patient_id)]

# Multiple probes test same genes
#sum(duplicated(fData(GSE36059)$`Gene Symbol`))

# List of the main genes
all_gene_symbols = unlist(lapply(strsplit(fData(GSE36059)$`Gene Symbol`, ' /// ', 1), `[`, 1))

# Get index of probe_ids to keep which are not duplicates or have NA values
#idx = which(!duplicated(fData(GSE36059)$`Gene Symbol`) & !is.na(fData(GSE36059)$`Gene Symbol`))
idx = which(!duplicated(all_gene_symbols) & !is.na(fData(GSE36059)$`Gene Symbol`) & !(fData(GSE36059)$`Gene Symbol` == ""))
# Remove duplicate gene probes & probes w/o gene names
eMat_GSE36059 = eMat_GSE36059[idx,]

# Print gene symbols
gene_symbols = fData(GSE36059) %>%
  dplyr::select(ID, `Gene Symbol`) 
kept_gene_symbols = gene_symbols[idx,] %>% dplyr::pull(`Gene Symbol`)

# Replace probe ids with gene names
rownames(eMat_GSE36059) = lapply(strsplit(kept_gene_symbols, ' /// ', 1), `[`, 1)


```

### GSE48581

https://onlinelibrary.wiley.com/doi/10.1111/ajt.12387



https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4788702/

According to the paper above, nephrectomy is usually performed on patients with autosomal-dominant polycystic kidney disease, which is a common hereditary disorder.
The patients with nephrectomy were included as a baseline according to the original paper of this dataset.

```{r}
GEO_GSE48581 = getGEO("GSE48581")
GSE48581 = GEO_GSE48581$GSE48581_series_matrix.txt.gz

# Load relevant matrices
eMat_GSE48581 = exprs(GSE48581)
p_GSE48581 = dplyr::rename(pData(GSE48581), diagnosis = `diagnosis (tcmr, abmr, mixed, non-rejecting, nephrectomy):ch1` )

# Rename non-rejecting level
p_GSE48581$diagnosis = gsub("non-rejecting", "NR", p_GSE48581$diagnosis)


# Remove rows & patient id with control diagnosis of nephrectomy or mixed
control_idx = which(p_GSE48581$diagnosis == "nephrectomy" | p_GSE48581$diagnosis == "mixed")
remove_patient_id = rownames(p_GSE48581)[control_idx]

# Remove from patient and expression dataset
p_GSE48581 = p_GSE48581[!(row.names(p_GSE48581) %in% remove_patient_id),]
eMat_GSE48581 = eMat_GSE48581[, !(colnames(eMat_GSE48581) %in% remove_patient_id)]



# Multiple probes test same genes
#sum(duplicated(fData(GSE48581)$`Gene Symbol`))

# List of the main genes
all_gene_symbols = unlist(lapply(strsplit(fData(GSE48581)$`Gene Symbol`, ' /// ', 1), `[`, 1))

# Get index of probe_ids to keep which are not duplicates or have NA values
#idx = which(!duplicated(fData(GSE48581)$`Gene Symbol`) & !is.na(fData(GSE48581)$`Gene Symbol`))
idx = which(!duplicated(all_gene_symbols) & !is.na(fData(GSE48581)$`Gene Symbol`) & !(fData(GSE48581)$`Gene Symbol` == ""))
# Remove duplicate gene probes & probes w/o gene names
eMat_GSE48581 = eMat_GSE48581[idx,]

# Print gene symbols
gene_symbols = fData(GSE48581) %>%
  dplyr::select(ID, `Gene Symbol`) 
kept_gene_symbols = gene_symbols[idx,] %>% dplyr::pull(`Gene Symbol`)

# Replace probe ids with gene names
rownames(eMat_GSE48581) = lapply(strsplit(kept_gene_symbols, ' /// ', 1), `[`, 1)
```




### Further Cleaning

```{r}
# Check to ensure there aren't shared patients between datasets
intersect(rownames(pData(GSE36059)), rownames(pData(GSE48581)))

# Check if there is any differences in genes measured between two dataset
setdiff(rownames(eMat_GSE48581), rownames(eMat_GSE36059))

```

## Joining & Merging

Joining & merging datasets from different batches i.e. experiments is difficult because it's necessary to remove batch effects which are differences that are not clinically significant (technician, reagents, microarray chips, and other equipment). The following reference outlines many more possible causes.

Problems with merging: https://www.nature.com/articles/tpj201057#

In the past many other batch correction methods have been used e.g. mean centering & standardising variance. The standard way to do it now appears to be to use the ComBat method to batch-adjust the gene expression. It uses an empirical Bayes and is predicated on the notion that batch effects are systematic & affect many genes in a batch in a similar way e.g. (increasing expression or increasing variability.) It shrinks the batch effect parameter estimates towards the global mean of batch effect estimates.

Original Batch Correction: https://academic.oup.com/biostatistics/article/8/1/118/252073
In action: https://biodatamining.biomedcentral.com/articles/10.1186/s13040-020-00217-8


## Relative Gene Expression

https://www.researchgate.net/publication/289524168_Pathway_Analysis_State_of_the_Art

This paper explains what we do which is first select for genes using Over Representation Analysis (ORA). THere is some evidence to suggest there are weaknesses to this method.

https://www.pnas.org/doi/full/10.1073/pnas.0506580102

The following can be used for justifying procedure.

https://academic.oup.com/nar/article/43/7/e47/2414268?ref=https%3a%2f%2fgithubhelp.com&login=false

### Selecting Genes

#### Using limma on pairwise contrasts

```{r}
library(DT)

# Takes lmFit model, contrast matrix, condition (ABMR or TCMR), returns top table dataframe & genes selected
ORA_contrasts = function(fit, contrast_matrix, condition){
  # For linear model fit of microarray data, compute estimated coefficients and standard errors for given contrasts
  constrast_fit = contrasts.fit(fit, contrast = contrast_matrix[, condition])
  # Adjust standard errors towards empirical derived global value
  efit = eBayes(constrast_fit, robust = TRUE)
  # Show how many genes were significant
  #summary(decideTests(efit, adjust.method = "BH", p.value = 0.05))
  tT = topTable(efit, n = 200, p.value = 0.05)
  # Rounding because significant figures
  DT::datatable(round(tT[1:100,], 2))
  return(tT)
}

# Takes pData with diagnosis column at levels ("ABMR", "TCMR", "NR"), expression matrix, returns list of topTables
get_ORA_genes = function(patient_data, expression_matrix) {
  design = model.matrix(~0 + diagnosis, data = patient_data)
  colnames(design) = gsub("diagnosis", "", colnames(design))
  fit = lmFit(expression_matrix, design)
  CM = makeContrasts(ABMR = ABMR - NR,
                     TCMR = TCMR - NR,
                     levels = design)
  tT_ABMR = ORA_contrasts(fit, CM, "ABMR")
  tT_TCMR = ORA_contrasts(fit, CM, "TCMR")
  return(list("tT_ABMR" = tT_ABMR, "tT_TCMR" = tT_TCMR))
}


# Finds only the names of the ABMR vs Healthy genes significant to both datasets
tT_ABMR_48581 = get_ORA_genes(p_GSE48581, eMat_GSE48581)$tT_ABMR
tT_ABMR_36059 = get_ORA_genes(p_GSE36059, eMat_GSE36059)$tT_ABMR
genes_selected_ABMR = intersect(rownames(tT_ABMR_36059), rownames(tT_ABMR_48581))

# Finds only the names of the TCMR vs Healthy genes significant to both datasets
tT_TCMR_48581 = get_ORA_genes(p_GSE48581, eMat_GSE48581)$tT_TCMR
tT_TCMR_36059 = get_ORA_genes(p_GSE36059, eMat_GSE36059)$tT_TCMR
genes_selected_TCMR = intersect(rownames(tT_TCMR_36059), rownames(tT_TCMR_48581))

```

#### Average or Single Dataset Fold Change

We can either plot the following exploratory plots based on the average log fold change between the two datasets or generate single plots for each dataset. The plotting functions take in the same arguments for either choice. The plots which use average log fold change are the network plot and the KEGG pathway plot.

What I have realised is that the treeplot and dotplot don't actually consider logFC so it doesn't matter if there are multiple datasets. The treeplots end up involving the same pathways however it is possible that the differing branching (similarity) could mean that different sets of pathways are activated in symphony in different outcomes.

```{r}


# Input two toptables to be combined & significant genes
# Output single average log fold ratio table with ENTREZID
get_average_FC = function(topTable1, topTable2, genes_selected) {
  
  FC_1 = topTable1 %>% 
    dplyr::select(logFC) %>% 
    filter(rownames(topTable1) %in% genes_selected)
  
  FC_2 = topTable2 %>% 
    dplyr::select(logFC) %>% 
    filter(rownames(topTable2) %in% genes_selected)
  
  FC_avg = (FC_1+FC_2)/2
  
  translated = bitr(rownames(FC_avg),
                  fromType = "SYMBOL",
                  toType = "ENTREZID",
                  OrgDb = "org.Hs.eg.db"
                  )
  FC_ENTREZID = FC_avg %>%
    filter(rownames(FC_avg) %in% translated$SYMBOL)
  
  row.names(FC_ENTREZID) = translated$ENTREZID
  
  FC_ENTREZID = setNames(FC_ENTREZID$logFC, rownames(FC_ENTREZID))
  return(FC_ENTREZID)
}

# Input single toptable & significant genes
# Output single log fold ratio table with ENTREZID
get_single_FC = function(topTable, genes_selected) {
  
  FC = topTable %>% 
    dplyr::select(logFC) %>% 
    filter(rownames(topTable) %in% genes_selected)
  
  translated = bitr(rownames(FC),
                  fromType = "SYMBOL",
                  toType = "ENTREZID",
                  OrgDb = "org.Hs.eg.db"
                  )
  
  FC_ENTREZID = FC %>%
    filter(rownames(FC) %in% translated$SYMBOL)
  
  row.names(FC_ENTREZID) = translated$ENTREZID
  FC_ENTREZID = setNames(FC_ENTREZID$logFC, rownames(FC_ENTREZID))
  return(FC_ENTREZID)
}

# Get average log fold changes of significant genes between datasets
FC_ABMR_ENTREZID = get_average_FC(tT_ABMR_48581, tT_ABMR_36059, genes_selected_ABMR)
FC_TCMR_ENTREZID = get_average_FC(tT_TCMR_48581, tT_TCMR_36059, genes_selected_TCMR)

# Alternatively, get log fold changes of a single dataset
FC_ABMR_ENTREZID = get_single_FC(tT_ABMR_48581, genes_selected_ABMR)


```

### Visualisations

#### Molecular Signatures Functional Enrichment Network Plot

MSigDB is a database of molecular signatures database.
https://www.gsea-msigdb.org/gsea/msigdb/

The following plot requires the log fold changes of each gene.

```{r}


# Input vector with names as ENTREZID & log-fold change values, return enrich result
get_enrich = function(geneList) {
  
  # Retrieves human molecular signatures database v7.5.1
  # Category, H -> Hallmark Gene Sets, C7 -> Immunologic Signature Gene Sets
  msigdbr_df = msigdbr(species = "human", category = "H")
  
  # Prepare term to gene input
  msigdbr_t2g = msigdbr_df %>% dplyr::distinct(gs_name, entrez_gene) %>% as.data.frame()
  
  # Get over-representation results
  enrich = enricher(gene = names(geneList), TERM2GENE = msigdbr_t2g)
  return(enrich)
  
}

# Input vector with names as ENTREZID & log-fold change values, return network plot
make_network_plot = function(geneList){
  
  enrich = get_enrich(geneList)
  # ENTREZID to gene symbol 
  enrich_readable = setReadable(enrich, 'org.Hs.eg.db', 'ENTREZID')
  enrich_readable@result$Description = enrich_readable@result$Description %>%
    str_replace_all("_", " ") %>%
    str_to_sentence()
  
  # Plot a cnetplot
  p1 = cnetplot(enrich_readable, 
                showCategory = 6,
                categorySize="pvalue", 
                foldChange = geneList, 
                cex_label_gene = 0.3,
                colorEdge = TRUE,
                cex_label_category = 0.5
                )
  return(p1)
  
}


```



#### Dot Plot

Dot plot does not use the log fold change values.

```{r}

# Makes strings returned by msigdb look prettier
label_func = function(string){
  
  return(str_to_sentence(str_replace_all(string, "_", " ")))
  
}

# Input vector with names as ENTREZID & log-fold change values, return dotplot
make_dotplot = function(geneList){
  
  enrich = get_enrich(geneList)
  dotplot(enrich, label_format = label_func)
}



```

#### Tree plot

Tree plot does not use the log fold change values.

Following article could help explain why we see TNF-A -> NFKB response

https://www.frontiersin.org/articles/10.3389/fimmu.2019.00815/full

```{r}

# Input vector with names as ENTREZID & log-fold change values, return tree plot
make_treeplot = function(geneList){
  
  enrich = get_enrich(geneList)
  # ENTREZID to gene symbol 
  enrich_readable = setReadable(enrich, 'org.Hs.eg.db', 'ENTREZID')
  # Calculates pairwsie similarity using Jaccard's similarity index
  similiarity_enrich = pairwise_termsim(enrich_readable)
  # Tree plot where default agglomeration method uses ward.D
  p1 = treeplot(similiarity_enrich)
  return(p1)
  
}

```

#### KEGG Enrichment Analysis

Kyoto Encyclopedia of Genes and Genomes is a database which helps us understand high-level functional pathways.

```{r}
#search_kegg_organism('hsa', by='kegg_code')

# Searches for relevant pathways based on selected genes
kk = enrichKEGG(gene = translated$ENTREZID,
                organism = 'hsa',
                pvalueCutoff = 0.05)

# Shows upregulated pathways, pay attention to ID column
head(kk)

# Displays upregulated pathway of ID = 'hsa05332' in browser
browseKEGG(kk, 'hsa05332')

# Saves an image of the pathway in root as {ID}.pathview.png e.g. hsa05332.pathview.png
hsa05332 = pathview(gene.data  = geneList,
                     pathway.id = "hsa05332",
                     species    = "hsa",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

```

#### Using the Plot Functions

```{r}


make_network_plot(FC_ABMR_ENTREZID)
make_network_plot(FC_TCMR_ENTREZID)
make_dotplot(FC_ABMR_ENTREZID)
make_dotplot(FC_TCMR_ENTREZID)
make_treeplot(FC_ABMR_ENTREZID)
make_treeplot(FC_TCMR_ENTREZID)

```



### Selecting Genes Stable between Datasets

CPOP selects features that produce consistent effects between datasets irrespective of the noise. It starts by calculating pairwise log fold ratios by taking the pairwise differences between gene expression. The CPOP then uses a weighted Elastic Net regularised regression model to further select log fold ratios that are most stable between datasets. This improves the stability of the final model.

https://www.biorxiv.org/content/10.1101/2020.12.09.415927v1.full

https://sydneybiox.github.io/CPOP/articles/CPOP.html


```{r}

# Input two expression matrices, phenotype dataframes, significant genes, positive class (ABMR, TCMR)
# Output cpop result
get_cpop_result = function(exp_matrix1, exp_matrix2, pdata1, pdata2, genes_selected, positive_class){
  
  # Selects only significant genes from each expression matrix
  exp_matrix1_reduced = exp_matrix1[genes_selected,]
  exp_matrix2_reduced = exp_matrix2[genes_selected,]
  
  # Finds patients whom are either non-rejection or ABMR
  indx = which(pdata1$diagnosis == 'NR' | pdata1$diagnosis == positive_class)
  
  # Selects the correct patients from gene expression ratios & outcomes
  x1 = t(exp_matrix1_reduced[, indx])
  y1 = factor(pdata1$diagnosis[indx])
  
  indx = which(pdata2$diagnosis == 'NR' | pdata2$diagnosis == positive_class)
  
  x2 = t(exp_matrix2_reduced[, indx])
  y2 = factor(pdata2$diagnosis[indx])
  
  # Perform CPOP
  cpop_result = cpop_model(
  x1 = x1, x2 = x2,
  y1 = y1, y2 = y2,
  family = "binomial",
  alpha = 1,
  n_features = 10
  )
  
  # Find combined feature matrix
  features = bind_rows(data.frame(cpop_result$z1, check.names = FALSE), data.frame(cpop_result$z2, check.names = FALSE)) %>%
    dplyr::select(cpop_result$feature)
  
  return(list("cpop_result" = cpop_result, "features" =  features, "outcome" = c(y1, y2)))

}


```

#### CPOP on ABMR

```{r}

# Perform CPOP on expression matrices of ABMR vs Healthy and get stable pairwise gene ratios (features) and outcomes
abmr_cpop_results = get_cpop_result(eMat_GSE48581, eMat_GSE36059, p_GSE48581, p_GSE36059, genes_selected_ABMR, "ABMR")
 cpop_result = abmr_cpop_results$cpop_result
abmr_nonrej_features = abmr_cpop_results$features
abmr_nonrej_outcome = abmr_cpop_results$outcome

# Plot network plot of stable pairwise gene ratios
plot_cpop(cpop_result = cpop_result, type = "ggraph")

```

#### CPOP on TCMR

```{r}

# Perform CPOP on expression matrices of TCMR vs Healthy and get stable pairwise gene ratios (features) and outcomes
tcmr_cpop_results = get_cpop_result(eMat_GSE48581, eMat_GSE36059, p_GSE48581, p_GSE36059, genes_selected_TCMR, "TCMR")
 cpop_result = tcmr_cpop_results$cpop_result
tcmr_nonrej_features = tcmr_cpop_results$features
tcmr_nonrej_outcome = tcmr_cpop_results$outcome

# Plot network plot of stable pairwise gene ratios
plot_cpop(cpop_result = cpop_result, type = "ggraph")
tcmr_nonrej_features
```

## Model Building

### Random Forest Classifier

A generic cross-validation function.

```{r}

# n: number of samples
# cvK: fold number
# n_sim: number of repeats

cross_validation = function(n, cvK, n_sim, X, y){
  
  cv_rep_acc_rf = c()
  
  for (i in 1:n_sim) {
    cvSets =  cvTools::cvFolds(n, cvK)  # permute all the data, into 5 folds
    cv_acc_knn = cv_acc_svm = cv_acc_rf = c()
  
    for (j in 1:cvK) {
      test_id = cvSets$subsets[cvSets$which == j]
      X_test = X[test_id, ]
      X_train = X[-test_id, ]
      y_test = y[test_id]
      y_train = y[-test_id]
      
      ## KNN - 5 Nearest Neighbours
      fit5 = class::knn(
        train = X_train,
        test = X_test,
        cl = y_train,
        k=5
      )
      cv_acc_knn[j] = mean(y_test == fit5)
      
      ## SVM
      svm_res = e1071::svm(x = X_train, y = as.factor(y_train))
      fit = predict(svm_res, X_test)
      cv_acc_svm[j] = mean(y_test == fit)
  
      ## Random Forest
      rf_res <- randomForest::randomForest(x = X_train, y = as.factor(y_train))
      fit <- predict(rf_res, X_test)
      cv_acc_rf[j] = mean(y_test == fit)
    }
    cv_rep_acc_rf = append(cv_rep_acc_rf, mean(cv_acc_rf))
  }
  return(cv_rep_acc_rf)
}

```

Constructing a model based on random forest using log-fold ratios which were select using CPOP. 

```{r}

cvK = 5
n_sim = 1


#X = t(as.matrix(eMat_GSE48581_ratios %>% select(-1, -2)))
#y = p_GSE48581$diagnosis
#n = nrow(X)
#
#GSE48581_acc = cross_validation(n, cvK, n_sim, X, y)
#
#X = t(as.matrix(eMat_GSE36059_ratios %>% select(-1, -2)))
#y = gse_GSE360594$Outcome
#n = nrow(X)
#
#GSE36059_acc = cross_validation(n, cvK, n_sim, X, y)

X = tcmr_nonrej_features
y = tcmr_nonrej_outcome
n = nrow(X)

acc = cross_validation(n, cvK, n_sim, X, y)


boxplot(acc)

```

We can use an ensemble of different classifiers and take the median probability to generate a more stable prediction. Stability of your model/process is particularly important.

Methods section: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5470931/

We can potentially include a penalty for the comorbidities present in the transplant recipient by using the Charlson Comorbidity Score. However I can't find a dataset for this yet.
https://pubmed.ncbi.nlm.nih.gov/29731067/

Support Vector Machine
Random Forest
KNN
https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-017-1925-0


## Model Evaluation

#### 









## Model Interpretation
```{r}
pima
```




## Junk Code

### GSE21374

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2877953/

This paper which the dataset belongs to, created a molecular classifier for predicting future graft loss. It also has a time to failure/census which is quite good.

```{r}
GSE21374 = getGEO("GSE21374")
GSE21374 = GSE21374$GSE21374_series_matrix.txt.gz

eMat_GSE21374 = exprs(GSE21374)
rownames(eMat_GSE21374)
length(rownames(eMat_GSE21374))
fData(GSE21374)$`Gene Symbol`
pData(GSE21374)
```

### GSE98320

This dataset has 1208 samples. The clustering contains information about the predicted category of the kidney transplant based on microarray data.

Important to note that this dataset contains samples from GSE36059 & GSE48581 (See Methods of Paper below)
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5470931/

This dataset also uses a slightly different platform GPL15207 and matching on the Gene Symbol shows that there are 17344 genes matching between this dataset and all the other datasets on a platform GPL570.

In terms of the clustering in order they are: No Rejection, TCMR, ABMR, early-stage ABMR, fully-developed ABMR, late-stage ABMR
*  

```{r}
GSE98320 = getGEO("GSE98320")
GSE98320 = GSE98320$GSE98320_series_matrix.txt.gz

fData(GSE98320)$`Gene Symbol`

length(intersect(fData(GSE98320)$`Gene Symbol`, fData(GSE21374)$`Gene Symbol`))
length(fData(GSE21374)$`Gene Symbol`)
length(fData(GSE98320)$`Gene Symbol`)

eMat_GSE98320 = exprs(GSE98320)
pData(GSE98320)
dim(eMat_GSE98320)
```

### GSE34748

Transplant glomerulopathy can be attributed to ABMR as it is a histological sign of chronic tissue injury. The reference is below.
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8503253/

Here the dataset contains data on 20 patients with transplant glomerulopathy which we will add as ABMR replicates.

We have treated the control biopsies as no rejection as within this study, there were no circulating donor specific antibodies (DSA) after transplantation. It is possible that the immunosuppressive regime that the patient underwent may mask the diagnosis of TCMR. However, 

```{r}

GSE34748 = getGEO("GSE34748")
GSE34748 = GSE34748$GSE34748_series_matrix.txt.gz
GSE34748
pData(GSE34748)$title
```

### GSE51675

```{r}

GSE51675 = getGEO("GSE51675")

```

#### Highest Variability

This is an alternative method to select genes.

```{r}
# High Variability

large_var_GSE48581 = apply(eMat_GSE48581, 1, var)
large_var_GSE36059 = apply(eMat_GSE36059, 1, var)

# Top 50 genes by variance
GSE48581_top50 = names(tail(sort(large_var_GSE48581), 50))
GSE36059_top50 = names(tail(sort(large_var_GSE36059), 50))
setdiff(GSE48581_top50, GSE36059_top50)
genes_selected = intersect(GSE48581_top50, GSE36059_top50)


#ind_GSE46474 = tail(order(large_var_GSE46474), 50) 

```



DisGeNET is a database of gene-disease associations.
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5210640/



### Pairwise Expression Ratios

Justification for pairwise expression ratios.
https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2261-8

This code is technically not used at the moment since the package CPOP already calculates pairwise differences i.e. log fold ratios for us, however I think it is good to have here since we need to manually calculate log-fold ratios for new inferences.

https://stackoverflow.com/questions/27489193/pairwise-row-matrix-multiplication-in-r

The following code produces a list of vectors of combinations of two probes, then takes the difference in gene expression for each pair
`lapply(split(indx, col(indx)), function(x) eMat_GSE48581_reduced[x[1],]-eMat_GSE48581_reduced[x[2],])`
The lapply spits out a separate row result for each combination of probes. Do.call with row bind, binds them all together into a matrix
`do.call(rbind, lapply(split(indx, col(indx)), function(x) eMat_GSE48581_reduced[x[1],]-eMat_GSE48581_reduced[x[2],]))`

```{r}
eMat_GSE48581_reduced = eMat_GSE48581[genes_selected,]
eMat_GSE36059_reduced = eMat_GSE36059[genes_selected,]


# This takes combinations of the different genes and finds the difference in their expression
indx = combn(rownames(eMat_GSE48581_reduced),2)
combn_names = paste(t(indx)[,1], t(indx)[,2], sep='--')
eMat_GSE48581_ratios = cbind(combn_names, as.data.frame(do.call(rbind, lapply(split(indx, col(indx)), function(x) eMat_GSE48581_reduced[x[1],]-eMat_GSE48581_reduced[x[2],]))))
eMat_GSE48581_ratios = eMat_GSE48581_ratios %>% remove_rownames %>% column_to_rownames(var = "combn_names")

indx = combn(rownames(eMat_GSE36059_reduced),2)
eMat_GSE36059_ratios = cbind(combn_names, as.data.frame(do.call(rbind, lapply(split(indx, col(indx)), function(x) eMat_GSE36059_reduced[x[1],]-eMat_GSE36059_reduced[x[2],]))))
eMat_GSE36059_ratios = eMat_GSE36059_ratios %>% remove_rownames %>% column_to_rownames(var = "combn_names")

eMat_GSE48581_ratios
eMat_GSE36059_ratios

```



Junk EnrichKEGG code

```{r}

# Combined datasets into matrix
eMat_combined = cbind(eMat_GSE48581, eMat_GSE36059)

# Get only genes relevant to ABMR and TCMR respectively
eMat_combined_ABMR = eMat_combined[genes_selected_ABMR,]
eMat_combined_TCMR = eMat_combined[genes_selected_TCMR,]
# Get 
FC_TCMR = tT_TCMR[genes_selected_TCMR,]
FC_ABMR = tT_ABMR[genes_selected_ABMR,]

# Biological ID Translator
# Get ABMR genes
translated_ABMR = bitr(rownames(eMat_combined_ABMR),
     fromType = "SYMBOL",
     toType = "ENTREZID",
     OrgDb = "org.Hs.eg.db"
     )

# Get TCMR genes
translated_TCMR = bitr(rownames(eMat_combined_TCMR),
     fromType = "SYMBOL",
     toType = "ENTREZID",
     OrgDb = "org.Hs.eg.db"
     )

# Get gene list with ENTREZID

FC_ABMR_ENTREZID = FC_ABMR %>% 
  dplyr::select(logFC) %>% 
  filter(row.names(tT_ABMR) %in% translated_ABMR$SYMBOL)

row.names(tT_ABMR) %in% translated_ABMR$SYMBOL
row.names(FC_ABMR_ENTREZID) = translated_ABMR$ENTREZID

#UNSOLVED WHY THE FUCK IS THERE ONE EXTRA INDEX
FC_TCMR_ENTREZID = FC_TCMR %>% 
  dplyr::select(logFC) %>% 
  filter(row.names(tT_TCMR) %in% translated_TCMR$SYMBOL)
  
row.names(FC_TCMR_ENTREZID) = translated_TCMR$ENTREZID

# Get combined expression matrix with ENTREZID
eMat_combined_ABMR_ENTREZID = eMat_combined_ABMR[which(rownames(eMat_combined_ABMR) %in% translated_ABMR$SYMBOL), ]
rownames(eMat_combined_ABMR_ENTREZID) = translated_ABMR$ENTREZID

#UNSOLVED WHY THE FUCK IS THERE ONE EXTRA INDEX
eMat_combined_TCMR_ENTREZID = eMat_combined_TCMR[which(rownames(eMat_combined_TCMR) %in% translated_TCMR$SYMBOL), ]
rownames(eMat_combined_TCMR_ENTREZID) = translated_TCMR$ENTREZID






bitr(rownames(eMat_combined_ABMR_ENTREZID),
     fromType = "SYMBOL",
     toType = "ENTREZID",
     OrgDb = "org.Hs.eg.db"
     )

sum(duplicated(translated_TCMR$ENTREZID))


```


## Explainability

```{r}
# Required package for biomaRt
# BiocManager::install("biomaRt")
library(biomaRt)
ensembl = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl
GB_ACC = fData(GSE36059)$GB_ACC
dat = getBM(attributes = c("protein_id", "embl", "hgnc_symbol"), values = GB_ACC, mart = ensembl)


```


This library helps with the explainability by showing the molecular pathway that a gene is related to.

```{r}
library(msigdbr)

# Get all species in this database
msigdbr_species()

# All gene sets of a humans
all_gene_sets = msigdbr(species = "Homo sapiens")

all_gene_sets %>%
  filter(human_gene_symbol == "M87338")
head(all_gene_sets)
```




### Classifier Model for GSE36059
```{r}
count=0
for(i in a$`diagnosis:ch1`){
  if(i=="non-rejecting")
{
  GSE36059$outcome[count]="Stable"
}else if(i=="ABMR")
{
  GSE36059$outcome[count]="LongTermRejection"
}else if(i=="MIXED")
{
  GSE36059$outcome[count]="LongandShortTermRejection"
}else if(i=="TCMR")
{
  GSE36059$outcome[count]="ShortTermRejection"
}
  count=count+1
}

```

