---
title: "Main Analysis"
author: Matthew Shu; Raymond Huang; Hugo Ohlsson; Vasu Paliwal; Ruestam Bhangal; Jiani
  Tan
date: "03/04/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, results='hide', warning=FALSE, message=FALSE}
library(tidyverse)
library(devtools)
library(ggplot2)
library(stringr)
library(stringdist)
library(GEOquery) 
library(R.utils)
library(Biobase)
library(reshape2)
library(ggplot2)
library(limma)
library(stats)
library(blorr)
library(viridis)
library(plotly)
library(ggrepel)
library(CPOP)
library(clusterProfiler)
library(DOSE)
library(org.Hs.eg.db)
library(pathview)
library(enrichplot)
library(msigdbr)
library
#BiocManager::install("sva")
```

## Inspiration / Overall Focus

https://imageo.genyo.es/

The following is an excerpt from GSE36059 report. It outlines the clinical recommendations that could be made off the back of being able to differentiate TCMR from ABMR. It is important to note that these biopsies are taken post-transplant.

"
The significance of the AKI score is dictated by the inducing
insult, which can be:
(1) self-limited, for example, early AKI in kidney transplants;
(2) treatable, for example, TCMR;
(3) difficult to treat and sustained, for example, late ABMR
or recurrent glomerulonephritis.
The conclusion that progression in troubled transplants is
primarily a function of ongoing parenchymal injury, not
destructive fibrosis, has promising therapeutic implications:
if we can arrest the disease that is wounding nephrons (e.g.
ABMR) before the renal tissue is too badly damaged, the
kidney will stabilize. The corollary is that treatments directed
at arresting fibrosis may not be useful because they fail to
address the cause of parenchymal injury.
...

TCMR after treatment in experienced centers is not
associated with reduced graft survival if there is no ABMR,
although TCMR should always trigger a review of the
immunosuppressive drug (ISD) prescription and patient
adherence. 


"

How to treat ABMR 
https://pubmed.ncbi.nlm.nih.gov/31895348/

## Datasets Ingestion & Cleaning

### GSE36059

https://www.sciencedirect.com/science/article/pii/S0085253815561863#bb0095



Human leukocyte antigen (HLA) antibodies were initially recognised as responsible for the immediate, hyperacute rejection of kidney grafts. Later we began to distinguish between two more types of rejection.

*  TCMR (T-cell Mediated Rejection) 
*  ABMR (Antibody Mediated Rejection)

C4d is a complement component i.e. molecule that tends to build up in the peritubular capillaries of kidneys, and was found to be a hallmark of anti-body mediated rejection. ABMR could both affect patients immediately (those who were presensitised) or much later due to de novo DSA production i.e. their body starting producing new antibodies against the donor's tissue. Both would eventually end up in end-stage renal failure.

It seems that this research finds ABMR to be primarily linked to a high probability of end-stage renal failure whereas TCMR probability of renal failure actually decreases over time. Distinguishing these could provide crucial clinical details as timing is a major factor in decision making.

![image](https://ars.els-cdn.com/content/image/1-s2.0-S0085253815561863-gr1.jpg)
Entrez Gene ID are unique alphanumeric identifiers for genes and other loci.

```{r}
# Reading in Data
GEO_GSE36059 = getGEO("GSE36059")
GSE36059 = GEO_GSE36059$GSE36059_series_matrix.txt.gz

# Example of functions that return patient data, feature data, expression matrix
head(pData(GSE36059)[,1:5])
head(fData(GSE36059)[,1:5])
head(exprs(GSE36059)[,1:5])

# How to return gene names
rownames(eMat_GSE36059)
length(rownames(eMat_GSE36059))

# Load relevant matrices
eMat_GSE36059 = exprs(GSE36059)
p_GSE36059 = dplyr::rename(pData(GSE36059), diagnosis = `diagnosis:ch1`)
p_GSE36059$diagnosis = gsub("non-rejecting", "NR", p_GSE36059$diagnosis)

# Rows & patient id with control diagnosis of nephrectomy
control_idx = which(p_GSE36059$diagnosis == "nephrectomy")
remove_patient_id = rownames(p_GSE36059)[control_idx]

# Remove controls from patient and expression dataset
p_GSE36059 = p_GSE36059[!(row.names(p_GSE36059) %in% remove_patient_id),]
eMat_GSE36059 = eMat_GSE36059[, !(colnames(eMat_GSE36059) %in% remove_patient_id)]

# Multiple probes test same genes
sum(duplicated(fData(GSE36059)$`Gene Symbol`))

# List of the main genes
all_gene_symbols = unlist(lapply(strsplit(fData(GSE36059)$`Gene Symbol`, ' /// ', 1), `[`, 1))

# Get index of probe_ids to keep which are not duplicates or have NA values
#idx = which(!duplicated(fData(GSE36059)$`Gene Symbol`) & !is.na(fData(GSE36059)$`Gene Symbol`))
idx = which(!duplicated(all_gene_symbols) & !is.na(fData(GSE36059)$`Gene Symbol`) & !(fData(GSE36059)$`Gene Symbol` == ""))
# Remove duplicate gene probes & probes w/o gene names
eMat_GSE36059 = eMat_GSE36059[idx,]

# Print gene symbols
gene_symbols = fData(GSE36059) %>%
  dplyr::select(ID, `Gene Symbol`) 
kept_gene_symbols = gene_symbols[idx,] %>% dplyr::pull(`Gene Symbol`)

# Replace probe ids with gene names
rownames(eMat_GSE36059) = lapply(strsplit(kept_gene_symbols, ' /// ', 1), `[`, 1)


```

### GSE48581

https://onlinelibrary.wiley.com/doi/10.1111/ajt.12387



https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4788702/

According to the paper above, nephrectomy is usually performed on patients with autosomal-dominant polycystic kidney disease, which is a common hereditary disorder.
The patients with nephrectomy were included as a baseline according to the original paper of this dataset.

```{r}
GEO_GSE48581 = getGEO("GSE48581")
GSE48581 = GEO_GSE48581$GSE48581_series_matrix.txt.gz

# Load relevant matrices
eMat_GSE48581 = exprs(GSE48581)
p_GSE48581 = dplyr::rename(pData(GSE48581), diagnosis = `diagnosis (tcmr, abmr, mixed, non-rejecting, nephrectomy):ch1` )

# Rename non-rejecting level
p_GSE48581$diagnosis = gsub("non-rejecting", "NR", p_GSE48581$diagnosis)


# Remove rows & patient id with control diagnosis of nephrectomy or mixed
control_idx = which(p_GSE48581$diagnosis == "nephrectomy" | p_GSE48581$diagnosis == "mixed")
remove_patient_id = rownames(p_GSE48581)[control_idx]

# Remove from patient and expression dataset
p_GSE48581 = p_GSE48581[!(row.names(p_GSE48581) %in% remove_patient_id),]
eMat_GSE48581 = eMat_GSE48581[, !(colnames(eMat_GSE48581) %in% remove_patient_id)]


p_GSE48581$diagnosis



# Multiple probes test same genes
sum(duplicated(fData(GSE48581)$`Gene Symbol`))

# List of the main genes
all_gene_symbols = unlist(lapply(strsplit(fData(GSE48581)$`Gene Symbol`, ' /// ', 1), `[`, 1))

# Get index of probe_ids to keep which are not duplicates or have NA values
#idx = which(!duplicated(fData(GSE48581)$`Gene Symbol`) & !is.na(fData(GSE48581)$`Gene Symbol`))
idx = which(!duplicated(all_gene_symbols) & !is.na(fData(GSE48581)$`Gene Symbol`) & !(fData(GSE48581)$`Gene Symbol` == ""))
# Remove duplicate gene probes & probes w/o gene names
eMat_GSE48581 = eMat_GSE48581[idx,]

# Print gene symbols
gene_symbols = fData(GSE48581) %>%
  dplyr::select(ID, `Gene Symbol`) 
kept_gene_symbols = gene_symbols[idx,] %>% dplyr::pull(`Gene Symbol`)

# Replace probe ids with gene names
rownames(eMat_GSE48581) = lapply(strsplit(kept_gene_symbols, ' /// ', 1), `[`, 1)
```




### Further Cleaning

```{r}
# Check to ensure there aren't shared patients between datasets
intersect(rownames(pData(GSE36059)), rownames(pData(GSE48581)))

# Check if there is any differences in genes measured between two dataset
setdiff(rownames(eMat_GSE48581), rownames(eMat_GSE36059))

```

## Joining & Merging

Joining & merging datasets from different batches i.e. experiments is difficult because it's necessary to remove batch effects which are differences that are not clinically significant (technician, reagents, microarray chips, and other equipment). The following reference outlines many more possible causes.

Problems with merging: https://www.nature.com/articles/tpj201057#

In the past many other batch correction methods have been used e.g. mean centering & standardising variance. The standard way to do it now appears to be to use the ComBat method to batch-adjust the gene expression. It uses an empirical Bayes and is predicated on the notion that batch effects are systematic & affect many genes in a batch in a similar way e.g. (increasing expression or increasing variability.) It shrinks the batch effect parameter estimates towards the global mean of batch effect estimates.

Original Batch Correction: https://academic.oup.com/biostatistics/article/8/1/118/252073
In action: https://biodatamining.biomedcentral.com/articles/10.1186/s13040-020-00217-8


## Relative Gene Expression

https://www.researchgate.net/publication/289524168_Pathway_Analysis_State_of_the_Art

This paper explains what we do which is first select for genes using Over Representation Analysis (ORA). THere is some evidence to suggest there are weaknesses to this method.

https://www.pnas.org/doi/full/10.1073/pnas.0506580102

The following can be used for justifying procedure.

https://academic.oup.com/nar/article/43/7/e47/2414268?ref=https%3a%2f%2fgithubhelp.com&login=false

### Selecting Genes

#### Using limma on pairwise contrasts

```{r}
library(DT)

# Takes lmFit model, contrast matrix, condition (ABMR or TCMR), returns top table dataframe & genes selected
ORA_contrasts = function(fit, contrast_matrix, condition){
  # For linear model fit of microarray data, compute estimated coefficients and standard errors for given contrasts
  constrast_fit = contrasts.fit(fit, contrast = contrast_matrix[, condition])
  # Adjust standard errors towards empirical derived global value
  efit = eBayes(constrast_fit, robust = TRUE)
  # Show how many genes were significant
  #summary(decideTests(efit, adjust.method = "BH", p.value = 0.05))
  tT = topTable(efit, n = 200, p.value = 0.05)
  # Rounding because significant figures
  DT::datatable(round(tT[1:100,], 2))
  return(tT)
}

# Takes pData with diagnosis column at levels ("ABMR", "TCMR", "NR"), expression matrix, returns list of topTables
get_ORA_genes = function(patient_data, expression_matrix) {
  design = model.matrix(~0 + diagnosis, data = patient_data)
  colnames(design) = gsub("diagnosis", "", colnames(design))
  fit = lmFit(expression_matrix, design)
  CM = makeContrasts(ABMR = ABMR - NR,
                     TCMR = TCMR - NR,
                     levels = design)
  tT_ABMR = ORA_contrasts(fit, CM, "ABMR")
  tT_TCMR = ORA_contrasts(fit, CM, "TCMR")
  return(list("tT_ABMR" = tT_ABMR, "tT_TCMR" = tT_TCMR))
}


tT_ABMR_48581 = get_ORA_genes(p_GSE48581, eMat_GSE48581)$tT_ABMR
tT_ABMR_36059 = get_ORA_genes(p_GSE36059, eMat_GSE36059)$tT_ABMR
genes_selected_ABMR = intersect(rownames(tT_ABMR_36059), rownames(tT_ABMR_48581))


tT_TCMR_48581 = get_ORA_genes(p_GSE48581, eMat_GSE48581)$tT_TCMR
tT_TCMR_36059 = get_ORA_genes(p_GSE36059, eMat_GSE36059)$tT_TCMR
genes_selected_TCMR = intersect(rownames(tT_TCMR_36059), rownames(tT_TCMR_48581))

```

#### Testing Combined logFC by Averaging (DON'T RUN)

What I have realised is that the treeplot and dotplot don't actually consider logFC so it doesn't matter if there are multiple datasets. The treeplots end up involving the same pathways however it is possible that the differing branching (similarity) could mean that different sets of pathways are activated in symphony in different outcomes.

```{r}
# TESTING BELOW
genes_selected = intersect(rownames(tT_ABMR_36059), rownames(tT_ABMR_48581))

#FC_1 = tT_ABMR_36059 %>% 
#  dplyr::select(logFC) %>% 
#  filter(rownames(tT_ABMR_36059) %in% genes_selected)
#
#FC_2 = tT_ABMR_48581 %>% 
#  dplyr::select(logFC) %>% 
#  filter(rownames(tT_ABMR_36059) %in% genes_selected)

#FC_ABMR = (FC_1+FC_2)/2

FC_ABMR = tT_ABMR_36059 %>% 
  dplyr::select(logFC) %>% 
  filter(rownames(tT_ABMR_36059) %in% genes_selected)



translated = bitr(rownames(FC_ABMR),
                  fromType = "SYMBOL",
                  toType = "ENTREZID",
                  OrgDb = "org.Hs.eg.db"
                  )
FC_ABMR_ENTREZID = FC_ABMR %>%
  filter(rownames(FC_ABMR) %in% translated$SYMBOL)
row.names(FC_ABMR_ENTREZID) = translated$ENTREZID
FC_ABMR_ENTREZID
```


```{r}
# TESTING BELOW
genes_selected = intersect(rownames(tT_TCMR_36059), rownames(tT_TCMR_48581))

#FC_1 = tT_TCMR_36059 %>% 
#  dplyr::select(logFC) %>% 
#  filter(rownames(tT_TCMR_36059) %in% genes_selected)
#
#FC_2 = tT_TCMR_48581 %>% 
#  dplyr::select(logFC) %>% 
#  filter(rownames(tT_TCMR_36059) %in% genes_selected)
#
#FC_TCMR = (FC_1+FC_2)/2

FC_TCMR = tT_TCMR_48581 %>% 
  dplyr::select(logFC) %>% 
  filter(rownames(tT_TCMR_48581) %in% genes_selected)
  
translated = bitr(rownames(FC_TCMR),
                  fromType = "SYMBOL",
                  toType = "ENTREZID",
                  OrgDb = "org.Hs.eg.db"
                  )
FC_TCMR_ENTREZID = FC_TCMR %>%
  filter(rownames(FC_TCMR) %in% translated$SYMBOL)
row.names(FC_TCMR_ENTREZID) = translated$ENTREZID
FC_TCMR_ENTREZID
```


#### KEGG Enrichment Analysis (DON'T RUN)

```{r}
#search_kegg_organism('hsa', by='kegg_code')

# Combined datasets into matrix
eMat_combined = cbind(eMat_GSE48581, eMat_GSE36059)

# Get only genes relevant to ABMR and TCMR respectively
eMat_combined_ABMR = eMat_combined[genes_selected_ABMR,]
eMat_combined_TCMR = eMat_combined[genes_selected_TCMR,]
# Get 
FC_TCMR = tT_TCMR[genes_selected_TCMR,]
FC_ABMR = tT_ABMR[genes_selected_ABMR,]

# Biological ID Translator
# Get ABMR genes
translated_ABMR = bitr(rownames(eMat_combined_ABMR),
     fromType = "SYMBOL",
     toType = "ENTREZID",
     OrgDb = "org.Hs.eg.db"
     )

# Get TCMR genes
translated_TCMR = bitr(rownames(eMat_combined_TCMR),
     fromType = "SYMBOL",
     toType = "ENTREZID",
     OrgDb = "org.Hs.eg.db"
     )

# Get gene list with ENTREZID

FC_ABMR_ENTREZID = FC_ABMR %>% 
  dplyr::select(logFC) %>% 
  filter(row.names(tT_ABMR) %in% translated_ABMR$SYMBOL)

row.names(tT_ABMR) %in% translated_ABMR$SYMBOL
row.names(FC_ABMR_ENTREZID) = translated_ABMR$ENTREZID

#UNSOLVED WHY THE FUCK IS THERE ONE EXTRA INDEX
FC_TCMR_ENTREZID = FC_TCMR %>% 
  dplyr::select(logFC) %>% 
  filter(row.names(tT_TCMR) %in% translated_TCMR$SYMBOL)
  
row.names(FC_TCMR_ENTREZID) = translated_TCMR$ENTREZID

# Get combined expression matrix with ENTREZID
eMat_combined_ABMR_ENTREZID = eMat_combined_ABMR[which(rownames(eMat_combined_ABMR) %in% translated_ABMR$SYMBOL), ]
rownames(eMat_combined_ABMR_ENTREZID) = translated_ABMR$ENTREZID

#UNSOLVED WHY THE FUCK IS THERE ONE EXTRA INDEX
eMat_combined_TCMR_ENTREZID = eMat_combined_TCMR[which(rownames(eMat_combined_TCMR) %in% translated_TCMR$SYMBOL), ]
rownames(eMat_combined_TCMR_ENTREZID) = translated_TCMR$ENTREZID






bitr(rownames(eMat_combined_ABMR_ENTREZID),
     fromType = "SYMBOL",
     toType = "ENTREZID",
     OrgDb = "org.Hs.eg.db"
     )

sum(duplicated(translated_TCMR$ENTREZID))
kk = enrichKEGG(gene = translated$ENTREZID,
                organism = 'hsa',
                pvalueCutoff = 0.05)

# Shows upregulated pathways
head(kk)


browseKEGG(kk, 'hsa05332')

hsa04110 <- pathview(gene.data  = geneList,
                     pathway.id = "hsa05332",
                     species    = "hsa",
                     limit      = list(gene=max(abs(geneList)), cpd=1))

hsa04110

translated$ENTREZID[grepl("hsa05332", rownames(fc.kegg.sigmet.p.up), fixed=TRUE),]
```

MSigDB is a database of molecular signatures database.
https://www.gsea-msigdb.org/gsea/msigdb/


```{r}
library(DOSE)
library(msigdbr)

geneList = setNames(FC_TCMR_ENTREZID$logFC, rownames(FC_TCMR_ENTREZID))
geneList = setNames(FC_ABMR_ENTREZID$logFC, rownames(FC_ABMR_ENTREZID))

# Retrieves human molecular signatures database v7.5.1
# Category, H -> Hallmark Gene Sets, C7 -> Immunologic Signature Gene Sets
msigdbr_df = msigdbr(species = "human", category = "H")

# Prepare term to gene input
msigdbr_t2g = msigdbr_df %>% dplyr::distinct(gs_name, entrez_gene) %>% as.data.frame()

# Get over-representation results
enrich = enricher(gene = names(geneList), TERM2GENE = msigdbr_t2g)
enrich_readable = setReadable(enrich, 'org.Hs.eg.db', 'ENTREZID')
enrich_readable@result$Description = str_replace_all(enrich_readable@result$Description, "_", " ")

# Plot a cnetplot
p1 = cnetplot(enrich_readable, 
              showCategory = 5,
              categorySize="pvalue", 
              foldChange = geneList, 
              cex_label_gene = 0.5,
              colorEdge = TRUE,
              cex_label_category = 0.5
              )
p1

```

```{r}
library(stringr)
label_func = function(string){
  return(str_to_sentence(str_replace_all(string, "_", " ")))
}
dotplot(enrich, label_format = label_func)


```
Following article could help explain why we see TNF-A -> NFKB response

https://www.frontiersin.org/articles/10.3389/fimmu.2019.00815/full

```{r}
similiarity_enrich = pairwise_termsim(enrich_readable)
p1 = treeplot(similiarity_enrich)
p1
```


### Selecting Genes Stable between Datasets

CPOP selects features that produce consistent effects between datasets irrespective of the noise. It starts by calculating pairwise log fold ratios by taking the pairwise differences between gene expression. The CPOP then uses a weighted Elastic Net regularised regression model to further select log fold ratios that are most stable between datasets. This improves the stability of the final model.

https://www.biorxiv.org/content/10.1101/2020.12.09.415927v1.full

https://sydneybiox.github.io/CPOP/articles/CPOP.html

#### For Non-rejection & TCMR

```{r}

eMat_GSE48581_reduced = eMat_GSE48581[genes_selected_TCMR,]
eMat_GSE36059_reduced = eMat_GSE36059[genes_selected_TCMR,]


# Finds patients whom are either non-rejection or TCMR
indx = which(p_GSE48581$diagnosis == 'NR' | p_GSE48581$diagnosis == 'TCMR')

# Selects the correct patients from gene expression ratios & outcomes
x1 = t(eMat_GSE48581_reduced[, indx])
y1 = factor(p_GSE48581$diagnosis[indx])

indx = which(p_GSE36059$diagnosis == 'NR' | p_GSE36059$diagnosis == 'TCMR')

x2 = t(eMat_GSE36059_reduced[, indx])
y2 = factor(p_GSE36059$diagnosis[indx])

cpop_result = cpop_model(
  x1 = x1, x2 = x2,
  y1 = y1, y2 = y2,
  family = "binomial",
  alpha = 1
)
```


```{r}
#plot_cpop(cpop_result = cpop_result, type = "text")

#names(cpop_result)

# This creates final joined dataframe based on selected gene combinations
tcmr_nonrej_features = bind_rows(data.frame(cpop_result$z1, check.names = FALSE), data.frame(cpop_result$z2, check.names = FALSE)) %>%
  select(cpop_result$feature)
tcmr_nonrej_outcome = c(y1, y2)

```

#### Network Plot - TCMR

```{r}
plot_cpop(cpop_result = cpop_result, type = "ggraph")

```

#### For Non-rejection & ABMR

Same as before.

```{r}

eMat_GSE48581_reduced = eMat_GSE48581[genes_selected_ABMR,]
eMat_GSE36059_reduced = eMat_GSE36059[genes_selected_ABMR,]

# Finds patients whom are either non-rejection or ABMR
indx = which(p_GSE48581$diagnosis == 'NR' | p_GSE48581$diagnosis == 'ABMR')

# Selects the correct patients from gene expression ratios & outcomes
x1 = t(eMat_GSE48581_reduced[, indx])
y1 = factor(p_GSE48581$diagnosis[indx])

indx = which(p_GSE36059$diagnosis == 'NR' | p_GSE36059$diagnosis == 'ABMR')

x2 = t(eMat_GSE36059_reduced[, indx])
y2 = factor(p_GSE36059$diagnosis[indx])


cpop_result = cpop_model(
  x1 = x1, x2 = x2,
  y1 = y1, y2 = y2,
  family = "binomial",
  alpha = 1
)
```

```{r}
# This creates final joined dataframe based on selected gene combinations
abmr_nonrej_features = bind_rows(data.frame(cpop_result$z1, check.names = FALSE), data.frame(cpop_result$z2, check.names = FALSE)) %>%
  select(cpop_result$feature)
abmr_nonrej_outcome = c(y1, y2)
```





### Random Forest Classifier

A generic cross-validation function.

```{r}

# n: number of samples
# cvK: fold number
# n_sim: number of repeats

cross_validation = function(n, cvK, n_sim, X, y){
  
  cv_rep_acc_rf = c()
  
  for (i in 1:n_sim) {
    cvSets =  cvTools::cvFolds(n, cvK)  # permute all the data, into 5 folds
    cv_acc_knn = cv_acc_svm = cv_acc_rf = c()
  
    for (j in 1:cvK) {
      test_id = cvSets$subsets[cvSets$which == j]
      X_test = X[test_id, ]
      X_train = X[-test_id, ]
      y_test = y[test_id]
      y_train = y[-test_id]
      
      ## KNN - 5 Nearest Neighbours
      fit5 = class::knn(
        train = X_train,
        test = X_test,
        cl = y_train,
        k=5
      )
      cv_acc_knn[j] = mean(y_test == fit5)
      
      ## SVM
      svm_res = e1071::svm(x = X_train, y = as.factor(y_train))
      fit = predict(svm_res, X_test)
      cv_acc_svm[j] = mean(y_test == fit)
  
      ## Random Forest
      rf_res <- randomForest::randomForest(x = X_train, y = as.factor(y_train))
      fit <- predict(rf_res, X_test)
      cv_acc_rf[j] = mean(y_test == fit)
    }
    cv_rep_acc_rf = append(cv_rep_acc_rf, mean(cv_acc_rf))
  }
  return(cv_rep_acc_rf)
}

```

Constructing a model based on random forest using log-fold ratios which were select using CPOP. 

```{r}

cvK = 5
n_sim = 1


#X = t(as.matrix(eMat_GSE48581_ratios %>% select(-1, -2)))
#y = p_GSE48581$diagnosis
#n = nrow(X)
#
#GSE48581_acc = cross_validation(n, cvK, n_sim, X, y)
#
#X = t(as.matrix(eMat_GSE36059_ratios %>% select(-1, -2)))
#y = gse_GSE360594$Outcome
#n = nrow(X)
#
#GSE36059_acc = cross_validation(n, cvK, n_sim, X, y)

X = tcmr_nonrej_features
y = tcmr_nonrej_outcome
n = nrow(X)

acc = cross_validation(n, cvK, n_sim, X, y)


boxplot(acc)

```

## Model Building

We can use an ensemble of different classifiers and take the median probability to generate a more stable prediction. Stability of your model/process is particularly important.

Methods section: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5470931/

We can potentially include a penalty for the comorbidities present in the transplant recipient by using the Charlson Comorbidity Score. However I can't find a dataset for this yet.
https://pubmed.ncbi.nlm.nih.gov/29731067/


### Classifier Model for GSE36059
```{r}
count=0
for(i in a$`diagnosis:ch1`){
  if(i=="non-rejecting")
{
  GSE36059$outcome[count]="Stable"
}else if(i=="ABMR")
{
  GSE36059$outcome[count]="LongTermRejection"
}else if(i=="MIXED")
{
  GSE36059$outcome[count]="LongandShortTermRejection"
}else if(i=="TCMR")
{
  GSE36059$outcome[count]="ShortTermRejection"
}
  count=count+1
}

```


## Model Selection

Support Vector Machine
Random Forest
KNN
https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-017-1925-0







## Model Evaluation











## Model Interpretation
```{r}
pima
```

## Explainability

```{r}
# Required package for biomaRt
# BiocManager::install("biomaRt")
library(biomaRt)
ensembl = useMart("ensembl", dataset = "hsapiens_gene_ensembl")
ensembl
GB_ACC = fData(GSE36059)$GB_ACC
dat = getBM(attributes = c("protein_id", "embl", "hgnc_symbol"), values = GB_ACC, mart = ensembl)


```


This library helps with the explainability by showing the molecular pathway that a gene is related to.

```{r}
library(msigdbr)

# Get all species in this database
msigdbr_species()

# All gene sets of a humans
all_gene_sets = msigdbr(species = "Homo sapiens")

all_gene_sets %>%
  filter(human_gene_symbol == "M87338")
head(all_gene_sets)
```


## Junk Code

### GSE21374

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC2877953/

This paper which the dataset belongs to, created a molecular classifier for predicting future graft loss. It also has a time to failure/census which is quite good.

```{r}
GSE21374 = getGEO("GSE21374")
GSE21374 = GSE21374$GSE21374_series_matrix.txt.gz

eMat_GSE21374 = exprs(GSE21374)
rownames(eMat_GSE21374)
length(rownames(eMat_GSE21374))
fData(GSE21374)$`Gene Symbol`
pData(GSE21374)
```

### GSE98320

This dataset has 1208 samples. The clustering contains information about the predicted category of the kidney transplant based on microarray data.

Important to note that this dataset contains samples from GSE36059 & GSE48581 (See Methods of Paper below)
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5470931/

This dataset also uses a slightly different platform GPL15207 and matching on the Gene Symbol shows that there are 17344 genes matching between this dataset and all the other datasets on a platform GPL570.

In terms of the clustering in order they are: No Rejection, TCMR, ABMR, early-stage ABMR, fully-developed ABMR, late-stage ABMR
*  

```{r}
GSE98320 = getGEO("GSE98320")
GSE98320 = GSE98320$GSE98320_series_matrix.txt.gz

fData(GSE98320)$`Gene Symbol`

length(intersect(fData(GSE98320)$`Gene Symbol`, fData(GSE21374)$`Gene Symbol`))
length(fData(GSE21374)$`Gene Symbol`)
length(fData(GSE98320)$`Gene Symbol`)

eMat_GSE98320 = exprs(GSE98320)
pData(GSE98320)
dim(eMat_GSE98320)
```

### GSE34748

Transplant glomerulopathy can be attributed to ABMR as it is a histological sign of chronic tissue injury. The reference is below.
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC8503253/

Here the dataset contains data on 20 patients with transplant glomerulopathy which we will add as ABMR replicates.

We have treated the control biopsies as no rejection as within this study, there were no circulating donor specific antibodies (DSA) after transplantation. It is possible that the immunosuppressive regime that the patient underwent may mask the diagnosis of TCMR. However, 

```{r}

GSE34748 = getGEO("GSE34748")
GSE34748 = GSE34748$GSE34748_series_matrix.txt.gz
GSE34748
pData(GSE34748)$title
```

### GSE51675

```{r}

GSE51675 = getGEO("GSE51675")

```

#### Highest Variability

This is an alternative method to select genes.

```{r}
# High Variability

large_var_GSE48581 = apply(eMat_GSE48581, 1, var)
large_var_GSE36059 = apply(eMat_GSE36059, 1, var)

# Top 50 genes by variance
GSE48581_top50 = names(tail(sort(large_var_GSE48581), 50))
GSE36059_top50 = names(tail(sort(large_var_GSE36059), 50))
setdiff(GSE48581_top50, GSE36059_top50)
genes_selected = intersect(GSE48581_top50, GSE36059_top50)


#ind_GSE46474 = tail(order(large_var_GSE46474), 50) 

```



DisGeNET is a database of gene-disease associations.
https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5210640/



### Pairwise Expression Ratios

Justification for pairwise expression ratios.
https://bmcbioinformatics.biomedcentral.com/articles/10.1186/s12859-018-2261-8

This code is technically not used at the moment since the package CPOP already calculates pairwise differences i.e. log fold ratios for us, however I think it is good to have here since we need to manually calculate log-fold ratios for new inferences.

https://stackoverflow.com/questions/27489193/pairwise-row-matrix-multiplication-in-r

The following code produces a list of vectors of combinations of two probes, then takes the difference in gene expression for each pair
`lapply(split(indx, col(indx)), function(x) eMat_GSE48581_reduced[x[1],]-eMat_GSE48581_reduced[x[2],])`
The lapply spits out a separate row result for each combination of probes. Do.call with row bind, binds them all together into a matrix
`do.call(rbind, lapply(split(indx, col(indx)), function(x) eMat_GSE48581_reduced[x[1],]-eMat_GSE48581_reduced[x[2],]))`

```{r}
eMat_GSE48581_reduced = eMat_GSE48581[genes_selected,]
eMat_GSE36059_reduced = eMat_GSE36059[genes_selected,]


# This takes combinations of the different genes and finds the difference in their expression
indx = combn(rownames(eMat_GSE48581_reduced),2)
combn_names = paste(t(indx)[,1], t(indx)[,2], sep='--')
eMat_GSE48581_ratios = cbind(combn_names, as.data.frame(do.call(rbind, lapply(split(indx, col(indx)), function(x) eMat_GSE48581_reduced[x[1],]-eMat_GSE48581_reduced[x[2],]))))
eMat_GSE48581_ratios = eMat_GSE48581_ratios %>% remove_rownames %>% column_to_rownames(var = "combn_names")

indx = combn(rownames(eMat_GSE36059_reduced),2)
eMat_GSE36059_ratios = cbind(combn_names, as.data.frame(do.call(rbind, lapply(split(indx, col(indx)), function(x) eMat_GSE36059_reduced[x[1],]-eMat_GSE36059_reduced[x[2],]))))
eMat_GSE36059_ratios = eMat_GSE36059_ratios %>% remove_rownames %>% column_to_rownames(var = "combn_names")

eMat_GSE48581_ratios
eMat_GSE36059_ratios

```